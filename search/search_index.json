{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"EAS 4803/8803\u2013Seismic Monitoring CO 2 Storage Instructor Felix J. Herrmann Phone: +1 (404) 385-7069 CODA, room S1375B TA Ziyi (Francis) Yin Email: ziyi.yin@gatech.edu General Information Time and Location Tue/Thur 03:30 PM - 04:45 PM in Skiles room 202 Office Hours: by appointment via Microsoft Teams Course Description Carbon Capture and Storage (CCS) is widely considered as a key technology to combat climate change. This course presents a comprehensive review how seismic imaging can be used to monitor underground (geologic) storage of carbon dioxide. Topics covered include basics of seismic data acquisition, wave propagation, and imaging, empirical relations between seismic and fluid-flow properties, two-phase flow equations describing CO 2 plumes, and the challenges of designing a seismic monitoring system for geologic CO 2 storage. COVID Georgia Tech is committed to promoting a campus community that supports holistic well-being, as well as empowering students to make choices that enable positive health outcomes. As we continue to live and learn through a pandemic, Georgia Tech strongly encourages students to utilize several tools not only to reduce their own risks of infection from Covid-19, but also to help reduce the overall levels of transmission in the community. These tools include: Getting fully vaccinated. Getting vaccinated at Tech is easy and free. Wearing face coverings consistently in all indoor settings and also in outdoor settings when in close proximity to others. Getting tested on a regular basis, regardless of whether you are vaccinated or asymptomatic. No appointment is needed for Georgia Tech\u2019s asymptomatic testing, and it is free. Avoiding touching your face until you have cleaned your hands with soap and water or used hand sanitizer. Immediately self-quarantining or self-isolating if you experience any symptoms that could be related to Covid-19 or if you have tested positive for Covid-19. Additional information and resources are available on the Tech Moving Forward website . Information Related to Covid-19 Students are expected to be familiar with and abide by the Institute guidelines, information, and updates related to Covid-19. Find campus operational updates, Frequently Asked Questions, and details on campus surveillance testing and vaccine appointments on the Tech Moving Forward website . Recordings of Class Sessions and Required Permissions Classes may not be recorded by students without the express consent of the instructor unless it is pursuant to an accommodation granted by the Office of Disability services. Class recordings, lectures, presentations, and other materials posted on Canvas are for the sole purpose of educating the students currently enrolled in the course. Students may not record or share the materials or recordings, including screen capturing or automated bots, unless the instructor gives permission. Digitally proctored exams may require students to engage the video camera, but those recordings will not be shared with or disclosed to others without consent unless legally permitted. For classes where participation is voluntary, students who participate with their camera engaged or utilize a profile image are agreeing to have their video or image recorded. For classes requiring class participation, if students are identifiable by their names, facial images, voices, and/ or comments, written consent must be obtained before sharing the recording with persons outside of currently enrolled students in the class. Course Material Textbook (ebook available from GT library) Ringrose, P. (2020), How to Store CO 2 Underground: insights from early-mover CCS Projects Recommended texts Sheriff, R. E., and L. P. Geldart (1995), Exploration Seismology (second edition), Cambridge University Express. Yilmaz, O. (2001), Seismic Data Analysis: Processing, Inversion, and Interpretation of Seismic Data, Society of Exploration Geophysicists. Yilmaz, O., SEG wiki page on Seismic Data Analysis Zhou, H. (2014), Practical Seismic Data Analysis, Cambridge University Press. Heiner Igel, Computational Seismology---A Practical Introduction Fichtner, Andreas, Full Seismic Waveform Modelling and Inversion Additional material will be made available under the tab Reading . Homework There will be homework exercises, which will mostly involve geophysics-related programs, computer simulations, and data analysis. These assignments is designed for each student to work by him/herself. This homework will count as 35% of your overall course grade. Project You are required to write a term paper on any topic related to monitoring of geologic CO 2 storage. This can be a literature review of a selected topic, or research project involving calculations, data analysis, or theoretical results done in consultation with the instructor. The topic needs to be approved by the instructor before the midterm. Your paper should be written up in a journal form with length, figures and referencing in a format suitable for submission to journals like Geophysical Research Letters (GRL). Preliminary version of the final paper should be shown to the instructor for approval at least two weeks before the final due date. You will present your term paper in a 15 minute AGU-style talk; a 12 minute presentation with 3 minutes of questions. The project will count as 15% of your overall course grade. Grading for your project will be based on the 12% of the quality of the research and the written paper, and 3% of your presentation. You can find more details on the Projects page. Exams There will be a midterm (25%) and a final exam (25%). Both of them are closed book. Reference to texts or other documents such as previous semester course materials during exams is strictly forbidden. Using these materials will be considered a direct violation of academic policy and will be dealt with according to the GT Academic Honor Code. The use of electronic devices (e.g. cellular phones, computers etc.) other than non-programmable calculators during exams and quizzes is not allowed. Evaluation Homework assignments (35%) Midterm exam (25%) Course project (15%) Final exam (25%) Academic Honesty It is expected that all students are aware of their individual responsibilities under the Georgia Tech Academic Honor Code, which will be strictly adhered to in this class. The complete text of the Georgia Tech Academic Honor Code is at http://www.honor.gatech.edu/ .","title":"EAS 4803/8803\u2013Seismic Monitoring CO~2~ Storage"},{"location":"#eas-48038803seismic-monitoring-co2-storage","text":"","title":"EAS 4803/8803\u2013Seismic Monitoring CO2 Storage"},{"location":"#instructor","text":"Felix J. Herrmann Phone: +1 (404) 385-7069 CODA, room S1375B","title":"Instructor"},{"location":"#ta","text":"Ziyi (Francis) Yin Email: ziyi.yin@gatech.edu","title":"TA"},{"location":"#general-information","text":"Time and Location Tue/Thur 03:30 PM - 04:45 PM in Skiles room 202 Office Hours: by appointment via Microsoft Teams","title":"General Information"},{"location":"#course-description","text":"Carbon Capture and Storage (CCS) is widely considered as a key technology to combat climate change. This course presents a comprehensive review how seismic imaging can be used to monitor underground (geologic) storage of carbon dioxide. Topics covered include basics of seismic data acquisition, wave propagation, and imaging, empirical relations between seismic and fluid-flow properties, two-phase flow equations describing CO 2 plumes, and the challenges of designing a seismic monitoring system for geologic CO 2 storage.","title":"Course Description"},{"location":"#covid","text":"Georgia Tech is committed to promoting a campus community that supports holistic well-being, as well as empowering students to make choices that enable positive health outcomes. As we continue to live and learn through a pandemic, Georgia Tech strongly encourages students to utilize several tools not only to reduce their own risks of infection from Covid-19, but also to help reduce the overall levels of transmission in the community. These tools include: Getting fully vaccinated. Getting vaccinated at Tech is easy and free. Wearing face coverings consistently in all indoor settings and also in outdoor settings when in close proximity to others. Getting tested on a regular basis, regardless of whether you are vaccinated or asymptomatic. No appointment is needed for Georgia Tech\u2019s asymptomatic testing, and it is free. Avoiding touching your face until you have cleaned your hands with soap and water or used hand sanitizer. Immediately self-quarantining or self-isolating if you experience any symptoms that could be related to Covid-19 or if you have tested positive for Covid-19. Additional information and resources are available on the Tech Moving Forward website .","title":"COVID"},{"location":"#information-related-to-covid-19","text":"Students are expected to be familiar with and abide by the Institute guidelines, information, and updates related to Covid-19. Find campus operational updates, Frequently Asked Questions, and details on campus surveillance testing and vaccine appointments on the Tech Moving Forward website .","title":"Information Related to Covid-19"},{"location":"#recordings-of-class-sessions-and-required-permissions","text":"Classes may not be recorded by students without the express consent of the instructor unless it is pursuant to an accommodation granted by the Office of Disability services. Class recordings, lectures, presentations, and other materials posted on Canvas are for the sole purpose of educating the students currently enrolled in the course. Students may not record or share the materials or recordings, including screen capturing or automated bots, unless the instructor gives permission. Digitally proctored exams may require students to engage the video camera, but those recordings will not be shared with or disclosed to others without consent unless legally permitted. For classes where participation is voluntary, students who participate with their camera engaged or utilize a profile image are agreeing to have their video or image recorded. For classes requiring class participation, if students are identifiable by their names, facial images, voices, and/ or comments, written consent must be obtained before sharing the recording with persons outside of currently enrolled students in the class.","title":"Recordings of Class Sessions and Required Permissions"},{"location":"#course-material","text":"","title":"Course Material"},{"location":"#textbook-ebook-available-from-gt-library","text":"Ringrose, P. (2020), How to Store CO 2 Underground: insights from early-mover CCS Projects","title":"Textbook (ebook available from GT library)"},{"location":"#recommended-texts","text":"Sheriff, R. E., and L. P. Geldart (1995), Exploration Seismology (second edition), Cambridge University Express. Yilmaz, O. (2001), Seismic Data Analysis: Processing, Inversion, and Interpretation of Seismic Data, Society of Exploration Geophysicists. Yilmaz, O., SEG wiki page on Seismic Data Analysis Zhou, H. (2014), Practical Seismic Data Analysis, Cambridge University Press. Heiner Igel, Computational Seismology---A Practical Introduction Fichtner, Andreas, Full Seismic Waveform Modelling and Inversion Additional material will be made available under the tab Reading .","title":"Recommended texts"},{"location":"#homework","text":"There will be homework exercises, which will mostly involve geophysics-related programs, computer simulations, and data analysis. These assignments is designed for each student to work by him/herself. This homework will count as 35% of your overall course grade.","title":"Homework"},{"location":"#project","text":"You are required to write a term paper on any topic related to monitoring of geologic CO 2 storage. This can be a literature review of a selected topic, or research project involving calculations, data analysis, or theoretical results done in consultation with the instructor. The topic needs to be approved by the instructor before the midterm. Your paper should be written up in a journal form with length, figures and referencing in a format suitable for submission to journals like Geophysical Research Letters (GRL). Preliminary version of the final paper should be shown to the instructor for approval at least two weeks before the final due date. You will present your term paper in a 15 minute AGU-style talk; a 12 minute presentation with 3 minutes of questions. The project will count as 15% of your overall course grade. Grading for your project will be based on the 12% of the quality of the research and the written paper, and 3% of your presentation. You can find more details on the Projects page.","title":"Project"},{"location":"#exams","text":"There will be a midterm (25%) and a final exam (25%). Both of them are closed book. Reference to texts or other documents such as previous semester course materials during exams is strictly forbidden. Using these materials will be considered a direct violation of academic policy and will be dealt with according to the GT Academic Honor Code. The use of electronic devices (e.g. cellular phones, computers etc.) other than non-programmable calculators during exams and quizzes is not allowed.","title":"Exams"},{"location":"#evaluation","text":"Homework assignments (35%) Midterm exam (25%) Course project (15%) Final exam (25%)","title":"Evaluation"},{"location":"#academic-honesty","text":"It is expected that all students are aware of their individual responsibilities under the Georgia Tech Academic Honor Code, which will be strictly adhered to in this class. The complete text of the Georgia Tech Academic Honor Code is at http://www.honor.gatech.edu/ .","title":"Academic Honesty"},{"location":"goals/","text":"Part 1 To be populated.","title":"Goals"},{"location":"goals/#part-1","text":"To be populated.","title":"Part 1"},{"location":"homework/","text":"Homework In this course, we will have a couple of coding assignments based on Julia , a fast, dynamic, reproducible composable and general open source programming language. You are encouraged to install Julia on your system following the script to run some basic coding experiments to explore its usage and applications in scientific computing community. In particular, you will run numerical experiments for CO \\(_2\\) dynamics simulation and also seismic wave-based simulations with academically developed softwares. To help you run these software, we highly recommend you use Docker, a platform which builds a virtual machine/container for you with the docker image, which is set-up by us and equipped with pre-installed softwares. The docker image is quite necessary for you to run the software without the tedious installation process, and to provide you with an environment on which the software runs out of the box. Docker First install docker for your system following the instruction here, https://www.docker.com/products/docker-desktop Instead of having to install Python, Julia, Devito, JUDI, FwiFlow and all the dependencies (these are the softwares that you will use for the numerical simulation) by yourself, you simply download the docker image and run it in a container. All you need to do is install docker, click the docker icon/app, open the terminal/command line ( powershell in windows, also see this ) on your system, and run: docker run -p 8888:8888 ziyiyin97/ccs-env:v4.2 This will download the image and launch a jupyter notebook that you can access from your internet browser. The command will display a link, which looks something like this: Copy/paste this URL into your browser when you connect for the first time, to login with a token: http://0e27b13128d4:8888/?token=84a95cf4319e8e68534f20c7c6474d9875f13c70270f35f4&token=84a95cf4319e8e68534f20c7c6474d9875f13c70270f35f4 Copy-paste this link and replace the address 0e27b13128d4:8888 with localhost:8888 (the link is created inside the docker container, which doesn't know that you mapped this port to your localhost w/ port no. 8888). Then, you can create a notebook there by clicking new -> notebook -> julia 1.7.1, and run the julia code in the jupyter notebook. Remember, the jupyter notebooks on the docker container don't stay there forever. Therefore, if you are half way on the homework and want to close the jupyter notebook, please remember to save the notebook to your local machine. If you do not want to save the notebook every time when you close the notebook, you can actually connect a folder on your machine to the docker container by docker run -v /path/on/your/machine:/notebooks -p 8888:8888 ziyiyin97/ccs-env:v4.2 where /path/on/your/machine is an absolute path on your own local machine. For example, if I want to connect the folder called testdocker on the desktop of my laptop, I can do docker run -v /Users/francisyin/Desktop/testdocker:/notebooks -p 8888:8888 ziyiyin97/ccs-env:v4.2 and then you will find the files in this folder will show up in the notebooks. Whatever you do on the docker container will also be saved in the local testdocker folder. Instead of a notebook, you can also launch an interactive session with a terminal by running: docker run -it ziyiyin97/ccs-env:v4.2 /bin/bash This will give you access to a terminal, in which you can start Julia/Python, run a couple of lines of code interactively. However, figures from PyPlot (the plotting package) sometimes do not render well from interactive julia sessions. Therefore, jupyter notebooks on docker are recommended for you to do the assignments. Window Users If you are using windows, you might need to enable hardware virtualization in their BIOS. You are suggested to look at here and here . If you have any question, please reach out to us ASAP. Some Useful Material Learn command line from Software Carpentry Learn jupyter notebook Learn Julia In-class Exercise During the lectures you will work on the following exercises Thickness of reservoir. Exercise 1 (Jan 20, 2022) Capacity coefficient. Exercise 2 (Jan 27, 2022) Homework Assignments During the course you will work on the following homework assignments Intro to rock physics. Assignment 1 . Submit your homework as a PDF report. (Due: 3:30 PM Jan 25, 2022) Fluid flow simulation. Intro to julia and Assignment 2 . Submit both jupyter notebook and a PDF file. (Due: 3:30 PM Feb 10, 2022) Wavefield extrapolation and migration. Assignment 3 (Due: 3:30 PM March 29, 2022) From processing to inversion I. Assignment 4 (Due: 3:30 PM April 12, 2022) Hand in Please turn in your assignments as pdf files. The assignments should be send to Ziyi (Francis) Yin . Late hand-ins are not accepted. If you have difficulty on the homework and want to ask for extension, please email Dr. Felix Herrmann and cc TA in advance (at least 2 days before the deadline). Feedback We will give you feedback on the marking of the exercises.","title":"Homework"},{"location":"homework/#homework","text":"In this course, we will have a couple of coding assignments based on Julia , a fast, dynamic, reproducible composable and general open source programming language. You are encouraged to install Julia on your system following the script to run some basic coding experiments to explore its usage and applications in scientific computing community. In particular, you will run numerical experiments for CO \\(_2\\) dynamics simulation and also seismic wave-based simulations with academically developed softwares. To help you run these software, we highly recommend you use Docker, a platform which builds a virtual machine/container for you with the docker image, which is set-up by us and equipped with pre-installed softwares. The docker image is quite necessary for you to run the software without the tedious installation process, and to provide you with an environment on which the software runs out of the box.","title":"Homework"},{"location":"homework/#docker","text":"First install docker for your system following the instruction here, https://www.docker.com/products/docker-desktop Instead of having to install Python, Julia, Devito, JUDI, FwiFlow and all the dependencies (these are the softwares that you will use for the numerical simulation) by yourself, you simply download the docker image and run it in a container. All you need to do is install docker, click the docker icon/app, open the terminal/command line ( powershell in windows, also see this ) on your system, and run: docker run -p 8888:8888 ziyiyin97/ccs-env:v4.2 This will download the image and launch a jupyter notebook that you can access from your internet browser. The command will display a link, which looks something like this: Copy/paste this URL into your browser when you connect for the first time, to login with a token: http://0e27b13128d4:8888/?token=84a95cf4319e8e68534f20c7c6474d9875f13c70270f35f4&token=84a95cf4319e8e68534f20c7c6474d9875f13c70270f35f4 Copy-paste this link and replace the address 0e27b13128d4:8888 with localhost:8888 (the link is created inside the docker container, which doesn't know that you mapped this port to your localhost w/ port no. 8888). Then, you can create a notebook there by clicking new -> notebook -> julia 1.7.1, and run the julia code in the jupyter notebook. Remember, the jupyter notebooks on the docker container don't stay there forever. Therefore, if you are half way on the homework and want to close the jupyter notebook, please remember to save the notebook to your local machine. If you do not want to save the notebook every time when you close the notebook, you can actually connect a folder on your machine to the docker container by docker run -v /path/on/your/machine:/notebooks -p 8888:8888 ziyiyin97/ccs-env:v4.2 where /path/on/your/machine is an absolute path on your own local machine. For example, if I want to connect the folder called testdocker on the desktop of my laptop, I can do docker run -v /Users/francisyin/Desktop/testdocker:/notebooks -p 8888:8888 ziyiyin97/ccs-env:v4.2 and then you will find the files in this folder will show up in the notebooks. Whatever you do on the docker container will also be saved in the local testdocker folder. Instead of a notebook, you can also launch an interactive session with a terminal by running: docker run -it ziyiyin97/ccs-env:v4.2 /bin/bash This will give you access to a terminal, in which you can start Julia/Python, run a couple of lines of code interactively. However, figures from PyPlot (the plotting package) sometimes do not render well from interactive julia sessions. Therefore, jupyter notebooks on docker are recommended for you to do the assignments.","title":"Docker"},{"location":"homework/#window-users","text":"If you are using windows, you might need to enable hardware virtualization in their BIOS. You are suggested to look at here and here . If you have any question, please reach out to us ASAP.","title":"Window Users"},{"location":"homework/#some-useful-material","text":"Learn command line from Software Carpentry Learn jupyter notebook Learn Julia","title":"Some Useful Material"},{"location":"homework/#in-class-exercise","text":"During the lectures you will work on the following exercises Thickness of reservoir. Exercise 1 (Jan 20, 2022) Capacity coefficient. Exercise 2 (Jan 27, 2022)","title":"In-class Exercise"},{"location":"homework/#homework-assignments","text":"During the course you will work on the following homework assignments Intro to rock physics. Assignment 1 . Submit your homework as a PDF report. (Due: 3:30 PM Jan 25, 2022) Fluid flow simulation. Intro to julia and Assignment 2 . Submit both jupyter notebook and a PDF file. (Due: 3:30 PM Feb 10, 2022) Wavefield extrapolation and migration. Assignment 3 (Due: 3:30 PM March 29, 2022) From processing to inversion I. Assignment 4 (Due: 3:30 PM April 12, 2022)","title":"Homework Assignments"},{"location":"homework/#hand-in","text":"Please turn in your assignments as pdf files. The assignments should be send to Ziyi (Francis) Yin . Late hand-ins are not accepted. If you have difficulty on the homework and want to ask for extension, please email Dr. Felix Herrmann and cc TA in advance (at least 2 days before the deadline).","title":"Hand in"},{"location":"homework/#feedback","text":"We will give you feedback on the marking of the exercises.","title":"Feedback"},{"location":"outline/","text":"Part 1 \u2013 Basics Geological Storage Motivation History fossil fuels History greenhouse gas Why CCS? Overview CCS goals Geological Storage Intro properties CO 2 capacity, injectivity, and containment important terms storage complex and time frame Porosity porous media & void space macroscopic properties density method typical porosities in clastic rocks fluid saturation Containment depth dependence rock properties trapping mechanisms storage security over time capillary forces and trapping Surface tension surface phenomena Laplace's Equation solid Surfaces and Wettibility capillary Pressure capillary Imbibition imbibition & Drainage Flow in Porous Media Darcy's Law Posseuille Flow Kozeny-Carman Equation CO 2 -brine relative permeability curves rock architecture at multiple scales geochemical processes CO 2 dissolution Calculating Storage Capacity density of CO 2 CO 2 emissions storage capacity estimation matched capacity Storage Capacity Estimation theoretical storage capacity trapping CO 2 as residual phase analytical approaches model for CO 2 plume CO 2 storage coefficient \\(C_c\\) effect of fluid mobility effect of gravity effect of buoyancy on capacity Sleipner example Flow dynamics flow regimes flow simulations static geological model dynamic two-phase flow simulations Sleipner example","title":"Outline"},{"location":"outline/#part-1-basics-geological-storage","text":"","title":"Part 1 \u2013 Basics Geological Storage"},{"location":"outline/#motivation","text":"History fossil fuels History greenhouse gas Why CCS? Overview CCS goals","title":"Motivation"},{"location":"outline/#geological-storage","text":"","title":"Geological Storage"},{"location":"outline/#intro","text":"properties CO 2 capacity, injectivity, and containment important terms storage complex and time frame","title":"Intro"},{"location":"outline/#porosity","text":"porous media & void space macroscopic properties density method typical porosities in clastic rocks fluid saturation","title":"Porosity"},{"location":"outline/#containment","text":"depth dependence rock properties trapping mechanisms storage security over time capillary forces and trapping","title":"Containment"},{"location":"outline/#surface-tension","text":"surface phenomena Laplace's Equation solid Surfaces and Wettibility capillary Pressure capillary Imbibition imbibition & Drainage","title":"Surface tension"},{"location":"outline/#flow-in-porous-media","text":"Darcy's Law Posseuille Flow Kozeny-Carman Equation CO 2 -brine relative permeability curves rock architecture at multiple scales geochemical processes CO 2 dissolution","title":"Flow in Porous Media"},{"location":"outline/#calculating-storage-capacity","text":"density of CO 2 CO 2 emissions storage capacity estimation matched capacity","title":"Calculating Storage Capacity"},{"location":"outline/#storage-capacity-estimation","text":"theoretical storage capacity trapping CO 2 as residual phase analytical approaches model for CO 2 plume CO 2 storage coefficient \\(C_c\\) effect of fluid mobility effect of gravity effect of buoyancy on capacity Sleipner example","title":"Storage Capacity Estimation"},{"location":"outline/#flow-dynamics","text":"flow regimes flow simulations static geological model dynamic two-phase flow simulations Sleipner example","title":"Flow dynamics"},{"location":"project/","text":"To be populated.","title":"Projects"},{"location":"reading/","text":"Material presented in class Part 1 - Basics Geological Storage Part 2 \u2013 Design & Scale Up Part 3 - Introduction Seismic Imaging Basics Seismic Imaging 1 Basics Seismic Imaging 2 Basics Seismic Imaging 3 Part 4 - Basics Migration Migration 1 Migration 2 Part 5 - Basics Seismic Data Acquisition Part 6 - Basics Inverse Problems Part 7 - Seismic Data Acquisition with Compressive Sensing Basics Compressive Sensing Timelape Compressive Sensing Part 8 - Full-waveform inversion and least-squares migration Recordings lectures Recording for Lecture 1 Recording for Lecture 2 Recording for Lecture 3 Recording for Lecture 4 Recording for Lecture 5 Recording for Lecture 6 Recording for Lecture 7 Recording for Lecture 8 Recording for Lecture 9 Recording for Lecture 9 Recording for Lecture 10 Recording for Lecture 11 Recording for Lecture 12 Recording for Lecture 13 Recording for Lecture 14 Recording Lecture 15 Recording Lecture 16 Recording Lecture 17 Recording Lecture 18 Reading material Parts 1 and 2 From the main text by Ringrose 1 read Chapter 1 and Chapter 2 until section 2.3, which was discussed during Lecture 1. In preparation of Lecture 2, read pages 17-29 from Chapter 2 of Gueguen 2 (for more background see also Chapter 1 ). Also read sections 2.3.1 and 2.3.2 of the main text by Ringrose 1 . In preparation of Lecture 3, Ringrose 1 book section 2.3.1 until 2.3.4 and pages 30-39 from Chapter 2 of Gueguen 2 . In preparation of Lecture 5, Ringrose 1 book section 2.3.5 until 2.4.5. In preparation of Lecture 6, Ringrose 1 book section 2.4.5 until 2.5.3. In preparation of Lecture 7, Ringrose 1 book section 2.5.4 until 2.7. In preparation of Lecture 8, Ringrose 1 book section 2.7.1 In preparation of Lecture 9, Ringrose 1 book section 2.7.2 until 2.7.3 and 3.1 until 3.3 In preparation of Lecture 11, Ringrose 1 book section 3.4 and 3.6 and 4. Reading material Part 3 John Scales: Theory of Seismic Imaging Chapters 1, 2, 10.3 Guy Drijkoningen: Introduction to Reflection Seismology TA3520 Chapter 5 and Seismic Data Processing - TG001 / TA3600 Chapters 1,2,3. Additional material In addition to the general text 1 , the course will review journal papers including Papers on Sleipner 3 4 5 Coupling seismic to fluid flow 6 Overview article 7 Philip Ringrose. How to Store CO2 Underground: insights from early-mover CCS Projects . Springer, 2020. URL: https://link.springer.com/book/10.1007/978-3-030-33113-9 . \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 Yves Gu\u00e9guen and Victor Palciauskas. Introduction to the Physics of Rocks . Princeton University Press, 1994. \u21a9 \u21a9 R. Arts, O. Eiken, A. Chadwick, P. Zweigel, L. van der Meer, and B. Zinszner. - monitoring of co2 injected at sleipner using time lapse seismic data. In J. Gale and Y. Kaya, editors, Greenhouse Gas Control Technologies - 6th International Conference , pages 347\u2013352. Pergamon, Oxford, 2003. URL: https://www.sciencedirect.com/science/article/pii/B9780080442761500568 , doi:https://doi.org/10.1016/B978-008044276-1/50056-8 . \u21a9 Ola Eiken, Philip Ringrose, Christian Hermanrud, Bamshad Nazarian, Tore A. Torp, and Lars H\u00f8ier. Lessons learned from 14 years of ccs operations: sleipner, in salah and sn\u00f8hvit. Energy Procedia , 4:5541\u20135548, 2011. 10th International Conference on Greenhouse Gas Control Technologies. URL: https://www.sciencedirect.com/science/article/pii/S1876610211008204 , doi:https://doi.org/10.1016/j.egypro.2011.02.541 . \u21a9 Anne-Kari Furre, Ola Eiken, H\u00e5vard Alnes, Jonas Nesland Vevatne, and Anders Fredrik Ki\u00e6r. 20 years of monitoring co2-injection at sleipner. Energy Procedia , 114:3916\u20133926, 2017. 13th International Conference on Greenhouse Gas Control Technologies, GHGT-13, 14-18 November 2016, Lausanne, Switzerland. URL: https://www.sciencedirect.com/science/article/pii/S1876610217317174 , doi:https://doi.org/10.1016/j.egypro.2017.03.1523 . \u21a9 Dongzhuo Li, Kailai Xu, Jerry M Harris, and Eric Darve. Coupled time-lapse full-waveform inversion for subsurface flow problems using intrusive automatic differentiation. Water Resources Research , 56 \\(8\\) :e2019WR027032, 2020. \u21a9 Philip S. Ringrose, Anne-Kari Furre, Stuart M.V. Gilfillan, Samuel Krevor, Martin Landr\u00f8, Rory Leslie, Tip Meckel, Bamshad Nazarian, and Adeel Zahid. Storage of carbon dioxide in saline aquifers: physicochemical processes, key constraints, and scale-up potential. Annual Review of Chemical and Biomolecular Engineering , 12 \\(1\\) :471\u2013494, 2021. PMID: 33872518. URL: https://doi.org/10.1146/annurev-chembioeng-093020-091447 , arXiv:https://doi.org/10.1146/annurev-chembioeng-093020-091447 , doi:10.1146/annurev-chembioeng-093020-091447 . \u21a9","title":"Reading"},{"location":"reading/#material-presented-in-class","text":"Part 1 - Basics Geological Storage Part 2 \u2013 Design & Scale Up Part 3 - Introduction Seismic Imaging Basics Seismic Imaging 1 Basics Seismic Imaging 2 Basics Seismic Imaging 3 Part 4 - Basics Migration Migration 1 Migration 2 Part 5 - Basics Seismic Data Acquisition Part 6 - Basics Inverse Problems Part 7 - Seismic Data Acquisition with Compressive Sensing Basics Compressive Sensing Timelape Compressive Sensing Part 8 - Full-waveform inversion and least-squares migration","title":"Material presented in class"},{"location":"reading/#recordings-lectures","text":"Recording for Lecture 1 Recording for Lecture 2 Recording for Lecture 3 Recording for Lecture 4 Recording for Lecture 5 Recording for Lecture 6 Recording for Lecture 7 Recording for Lecture 8 Recording for Lecture 9 Recording for Lecture 9 Recording for Lecture 10 Recording for Lecture 11 Recording for Lecture 12 Recording for Lecture 13 Recording for Lecture 14 Recording Lecture 15 Recording Lecture 16 Recording Lecture 17 Recording Lecture 18","title":"Recordings lectures"},{"location":"reading/#reading-material-parts-1-and-2","text":"From the main text by Ringrose 1 read Chapter 1 and Chapter 2 until section 2.3, which was discussed during Lecture 1. In preparation of Lecture 2, read pages 17-29 from Chapter 2 of Gueguen 2 (for more background see also Chapter 1 ). Also read sections 2.3.1 and 2.3.2 of the main text by Ringrose 1 . In preparation of Lecture 3, Ringrose 1 book section 2.3.1 until 2.3.4 and pages 30-39 from Chapter 2 of Gueguen 2 . In preparation of Lecture 5, Ringrose 1 book section 2.3.5 until 2.4.5. In preparation of Lecture 6, Ringrose 1 book section 2.4.5 until 2.5.3. In preparation of Lecture 7, Ringrose 1 book section 2.5.4 until 2.7. In preparation of Lecture 8, Ringrose 1 book section 2.7.1 In preparation of Lecture 9, Ringrose 1 book section 2.7.2 until 2.7.3 and 3.1 until 3.3 In preparation of Lecture 11, Ringrose 1 book section 3.4 and 3.6 and 4.","title":"Reading material Parts 1 and 2"},{"location":"reading/#reading-material-part-3","text":"John Scales: Theory of Seismic Imaging Chapters 1, 2, 10.3 Guy Drijkoningen: Introduction to Reflection Seismology TA3520 Chapter 5 and Seismic Data Processing - TG001 / TA3600 Chapters 1,2,3.","title":"Reading material Part 3"},{"location":"reading/#additional-material","text":"In addition to the general text 1 , the course will review journal papers including Papers on Sleipner 3 4 5 Coupling seismic to fluid flow 6 Overview article 7 Philip Ringrose. How to Store CO2 Underground: insights from early-mover CCS Projects . Springer, 2020. URL: https://link.springer.com/book/10.1007/978-3-030-33113-9 . \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 Yves Gu\u00e9guen and Victor Palciauskas. Introduction to the Physics of Rocks . Princeton University Press, 1994. \u21a9 \u21a9 R. Arts, O. Eiken, A. Chadwick, P. Zweigel, L. van der Meer, and B. Zinszner. - monitoring of co2 injected at sleipner using time lapse seismic data. In J. Gale and Y. Kaya, editors, Greenhouse Gas Control Technologies - 6th International Conference , pages 347\u2013352. Pergamon, Oxford, 2003. URL: https://www.sciencedirect.com/science/article/pii/B9780080442761500568 , doi:https://doi.org/10.1016/B978-008044276-1/50056-8 . \u21a9 Ola Eiken, Philip Ringrose, Christian Hermanrud, Bamshad Nazarian, Tore A. Torp, and Lars H\u00f8ier. Lessons learned from 14 years of ccs operations: sleipner, in salah and sn\u00f8hvit. Energy Procedia , 4:5541\u20135548, 2011. 10th International Conference on Greenhouse Gas Control Technologies. URL: https://www.sciencedirect.com/science/article/pii/S1876610211008204 , doi:https://doi.org/10.1016/j.egypro.2011.02.541 . \u21a9 Anne-Kari Furre, Ola Eiken, H\u00e5vard Alnes, Jonas Nesland Vevatne, and Anders Fredrik Ki\u00e6r. 20 years of monitoring co2-injection at sleipner. Energy Procedia , 114:3916\u20133926, 2017. 13th International Conference on Greenhouse Gas Control Technologies, GHGT-13, 14-18 November 2016, Lausanne, Switzerland. URL: https://www.sciencedirect.com/science/article/pii/S1876610217317174 , doi:https://doi.org/10.1016/j.egypro.2017.03.1523 . \u21a9 Dongzhuo Li, Kailai Xu, Jerry M Harris, and Eric Darve. Coupled time-lapse full-waveform inversion for subsurface flow problems using intrusive automatic differentiation. Water Resources Research , 56 \\(8\\) :e2019WR027032, 2020. \u21a9 Philip S. Ringrose, Anne-Kari Furre, Stuart M.V. Gilfillan, Samuel Krevor, Martin Landr\u00f8, Rory Leslie, Tip Meckel, Bamshad Nazarian, and Adeel Zahid. Storage of carbon dioxide in saline aquifers: physicochemical processes, key constraints, and scale-up potential. Annual Review of Chemical and Biomolecular Engineering , 12 \\(1\\) :471\u2013494, 2021. PMID: 33872518. URL: https://doi.org/10.1146/annurev-chembioeng-093020-091447 , arXiv:https://doi.org/10.1146/annurev-chembioeng-093020-091447 , doi:10.1146/annurev-chembioeng-093020-091447 . \u21a9","title":"Additional material"},{"location":"Assignments/Exercise1/","text":"Exercise 1: a first look at seismic data In this exercise we will load some data into Julia and perform some basic operations. Seismic data are typically stored in a special binary format: SEGY. These file-formats store the data as mutliple time-series (traces) with the corresponding header information containing specific information about such as time sampling and source/receiver locations. The Julia utilities for reading SEGY data is SegyIO using Pkg #Pkg.clone(\"https://github.com/slimgroup/SegyIO.jl.git\") #Pkg.add(\"PyPlot\") using SegyIO, PyPlot Scaning the dataset Thhe first step is to scan the dataset to extract header/metadat. This metadat contains the geometry and parameters of the survey such as the source/receiver locations and time sampling rate. The convention for the metadata is as follows: The Source positions use the Source keyword such as SourceX The receiver position use the Group keyword such as GroupX # scan the dataset dir = Pkg.dir(\"SegyIO\") data_dir = \"data\" \u250c Warning: `Pkg.dir(pkgname, paths...)` is deprecated; instead, do `import SegyIO; joinpath(dirname(pathof(SegyIO)), \"..\", paths...)`. \u2514 @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.2/Pkg/src/API.jl:415 \"data\" We can now scans the dataset with the segy_scan functin. This function returns a SeisCOn object where each block is a shot record with its metadata. blocks = segy_scan(string(dir, data_dir), \"overthrust\", [\"GroupX\", \"GroupY\", \"ns\", \"dt\"]); Scanning ... /home/yzhang3198/.julia/packages/SegyIO/ak2qG/data/overthrust_2D_shot_41_60.segy Scanning ... /home/yzhang3198/.julia/packages/SegyIO/ak2qG/data/overthrust_2D_shot_21_40.segy Scanning ... /home/yzhang3198/.julia/packages/SegyIO/ak2qG/data/overthrust_2D_shot_61_80.segy Scanning ... /home/yzhang3198/.julia/packages/SegyIO/ak2qG/data/overthrust_2D_shot_1_20.segy Scanning ... /home/yzhang3198/.julia/packages/SegyIO/ak2qG/data/overthrust_2D_shot_81_97.segy Now extract the time, source and receiver coordinates (in seconds and meters) for all the traces. The source and receiver vectors have a length equal to the number of traces, the time vector has a length equal to the number of rows in the data matrix. sx = [get_header(blocks[i], \"SourceX\") for i=1:length(blocks)]; rx = [get_header(blocks[i], \"GroupX\") for i=1:length(blocks)]; # Get the tme axis. In this case the time axis is the same for all traces so we only need to extract it from the first trace # dt needs to be corrected for the binary setup # All the times are in ms dt = get_header(blocks[1], \"dt\")[1]/1000 nt = get_header(blocks[1], \"ns\")[1] T = 0:dt:(nt-1)*dt 0.0:4.0:3000.0 Calculate the offset and midpoint for each trace. This gives you vectors m (midpoint) and h (offset) with length equal to the number of traces. h = (s - r)/2; m = (s + r)/2; h = (sx .- rx)./2; m = (sx .+ rx)./2; The fold of the data is the number of traces in each midpoint gather. This can be easily visualized by a histogram. As we have a set of blocks we need to inspect each block seperately to recover the nuique set of midpoint location and the total number fo traces for this midpoint all_m = hcat(m'...) fold = [sum(all_m .== unique(all_m)[i]) for i=1:length(unique(all_m))]; all_h = hcat(h'...); figure(); bar(unique(all_m),fold ,align=\"center\", width=100); xlabel(\"midpoint [m]\"); ylabel(\"fold\"); title(\"fold\"); Can you interpret this figure? Different gathers Extract a midpoint gather. For example, a midpoint gather at m = 2550 looks like this: Im = findall(all_m .== 7500.) figure() imshow(Float32.(blocks[1:97].data[:,map(i -> i[2], Im)]), vmin=-1, vmax=1, cmap=\"Greys\", aspect=0.05) PyObject <matplotlib.image.AxesImage object at 0x7f49363d4e48> Extract an offset-gather. For example, a zero-offset section looks like: Ih = findall(all_h .== 0.) inds = sortperm(all_m[Ih]) figure() imshow(Float32.(blocks[1:97].data[:,map(i -> i[2], Ih[inds])]), vmin=-1, vmax=1, cmap=\"Greys\", aspect=.1) PyObject <matplotlib.image.AxesImage object at 0x7f4935b5f860> What other different gathers can you think of? Extract and plot an example of all the different gathers. What are characteristic properties of the different gathers? Do not forget to label the axis and choose a reasonable colorscale. Hint: use cmap=Greys and adjust the color-axis vmin/vmax","title":"Exercise 1: a first look at seismic data"},{"location":"Assignments/Exercise1/#exercise-1-a-first-look-at-seismic-data","text":"In this exercise we will load some data into Julia and perform some basic operations. Seismic data are typically stored in a special binary format: SEGY. These file-formats store the data as mutliple time-series (traces) with the corresponding header information containing specific information about such as time sampling and source/receiver locations. The Julia utilities for reading SEGY data is SegyIO using Pkg #Pkg.clone(\"https://github.com/slimgroup/SegyIO.jl.git\") #Pkg.add(\"PyPlot\") using SegyIO, PyPlot","title":"Exercise 1: a first look at seismic data"},{"location":"Assignments/Exercise1/#scaning-the-dataset","text":"Thhe first step is to scan the dataset to extract header/metadat. This metadat contains the geometry and parameters of the survey such as the source/receiver locations and time sampling rate. The convention for the metadata is as follows: The Source positions use the Source keyword such as SourceX The receiver position use the Group keyword such as GroupX # scan the dataset dir = Pkg.dir(\"SegyIO\") data_dir = \"data\" \u250c Warning: `Pkg.dir(pkgname, paths...)` is deprecated; instead, do `import SegyIO; joinpath(dirname(pathof(SegyIO)), \"..\", paths...)`. \u2514 @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.2/Pkg/src/API.jl:415 \"data\" We can now scans the dataset with the segy_scan functin. This function returns a SeisCOn object where each block is a shot record with its metadata. blocks = segy_scan(string(dir, data_dir), \"overthrust\", [\"GroupX\", \"GroupY\", \"ns\", \"dt\"]); Scanning ... /home/yzhang3198/.julia/packages/SegyIO/ak2qG/data/overthrust_2D_shot_41_60.segy Scanning ... /home/yzhang3198/.julia/packages/SegyIO/ak2qG/data/overthrust_2D_shot_21_40.segy Scanning ... /home/yzhang3198/.julia/packages/SegyIO/ak2qG/data/overthrust_2D_shot_61_80.segy Scanning ... /home/yzhang3198/.julia/packages/SegyIO/ak2qG/data/overthrust_2D_shot_1_20.segy Scanning ... /home/yzhang3198/.julia/packages/SegyIO/ak2qG/data/overthrust_2D_shot_81_97.segy Now extract the time, source and receiver coordinates (in seconds and meters) for all the traces. The source and receiver vectors have a length equal to the number of traces, the time vector has a length equal to the number of rows in the data matrix. sx = [get_header(blocks[i], \"SourceX\") for i=1:length(blocks)]; rx = [get_header(blocks[i], \"GroupX\") for i=1:length(blocks)]; # Get the tme axis. In this case the time axis is the same for all traces so we only need to extract it from the first trace # dt needs to be corrected for the binary setup # All the times are in ms dt = get_header(blocks[1], \"dt\")[1]/1000 nt = get_header(blocks[1], \"ns\")[1] T = 0:dt:(nt-1)*dt 0.0:4.0:3000.0 Calculate the offset and midpoint for each trace. This gives you vectors m (midpoint) and h (offset) with length equal to the number of traces. h = (s - r)/2; m = (s + r)/2; h = (sx .- rx)./2; m = (sx .+ rx)./2; The fold of the data is the number of traces in each midpoint gather. This can be easily visualized by a histogram. As we have a set of blocks we need to inspect each block seperately to recover the nuique set of midpoint location and the total number fo traces for this midpoint all_m = hcat(m'...) fold = [sum(all_m .== unique(all_m)[i]) for i=1:length(unique(all_m))]; all_h = hcat(h'...); figure(); bar(unique(all_m),fold ,align=\"center\", width=100); xlabel(\"midpoint [m]\"); ylabel(\"fold\"); title(\"fold\"); Can you interpret this figure? Different gathers Extract a midpoint gather. For example, a midpoint gather at m = 2550 looks like this: Im = findall(all_m .== 7500.) figure() imshow(Float32.(blocks[1:97].data[:,map(i -> i[2], Im)]), vmin=-1, vmax=1, cmap=\"Greys\", aspect=0.05) PyObject <matplotlib.image.AxesImage object at 0x7f49363d4e48> Extract an offset-gather. For example, a zero-offset section looks like: Ih = findall(all_h .== 0.) inds = sortperm(all_m[Ih]) figure() imshow(Float32.(blocks[1:97].data[:,map(i -> i[2], Ih[inds])]), vmin=-1, vmax=1, cmap=\"Greys\", aspect=.1) PyObject <matplotlib.image.AxesImage object at 0x7f4935b5f860> What other different gathers can you think of? Extract and plot an example of all the different gathers. What are characteristic properties of the different gathers? Do not forget to label the axis and choose a reasonable colorscale. Hint: use cmap=Greys and adjust the color-axis vmin/vmax","title":"Scaning the dataset"},{"location":"Assignments/Exercise2/","text":"NMO correction The traveltime as a function of offset of a reflected event can be approximated by the NMO traveltime: $ \\tau(t_0,h) = \\sqrt{t_0 + h 2/v 2} $ where \\((t_0)\\) is the zero-offset or vertical traveltime and \\(v\\) is the effective or NMO velocity. We can now correct the data for the moveout via a simple coordinate transform: $ d_{NMO}(t_0,h) = d(\\tau(t_0,h),h) $ You can use the function nmo implemented below for this exercise. Please download data from Dropbox: https://www.dropbox.com/s/lhjuvaidcttigqg/data.zip?dl=0 Password is exact same with the password which you used to access the lecture note. using Pkg Pkg.add(\"Dierckx\") using Dierckx function nmo(cmp, t, off, v) # NMO correction and adjoint # # use: # out = nmo(in,t,h,v,flag) # # input: # in - data matrix of size [length(t) x length(h)], each column is a trace # t - time vector [s] # offsets - offset vector [m] # v - NMO velocity [m/s] as vector of size [length(t) x 1]. # flag - 1:forward, -1:adjoint # # output # out - data matrix of size [length(t) x length(h)], each column is a trace if size(cmp, 2) == 1 return cmp end # size of data nt, nh = size(cmp) # make sure t and v are column vectors t = t[:] v = v[:] # initialize output out = zeros(nt, nh) # loop over offset for i = 1:nh # NMO traveltime tau = sqrt.(t.^2 + off[i].^2 ./v.^2); # interpolate, forward or adjoint spl = Spline1D(t, cmp[1e-3*T.-t.<1e-5, i]) out[:,i] = spl(tau) end return out end \u001b[32m\u001b[1m Updating\u001b[22m\u001b[39m registry at `~/.julia/registries/General` \u001b[32m\u001b[1m Updating\u001b[22m\u001b[39m git-repo `https://github.com/JuliaRegistries/General.git` \u001b[2K\u001b[?25h[1mFetching:\u001b[22m\u001b[39m [========================================>] 100.0 %.0 %\u001b[32m\u001b[1m Resolving\u001b[22m\u001b[39m package versions... \u001b[32m\u001b[1m Updating\u001b[22m\u001b[39m `~/.julia/environments/v1.2/Project.toml` \u001b[90m [no changes]\u001b[39m \u001b[32m\u001b[1m Updating\u001b[22m\u001b[39m `~/.julia/environments/v1.2/Manifest.toml` \u001b[90m [no changes]\u001b[39m nmo (generic function with 1 method) using SegyIO, PyPlot # read the dataset blocks = segy_read(\"/home/yzhang3198/Downloads/data_segy/cube2.segy\"); \u250c Warning: Fixed length trace flag set in stream: IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=90663444, maxsize=Inf, ptr=3601, mark=-1) \u2514 @ SegyIO /home/yzhang3198/.julia/packages/SegyIO/ak2qG/src/read/read_file.jl:26 sx = get_header(blocks, \"SourceX\";scale=false) rx = get_header(blocks, \"GroupX\";scale=false); # Get the time axis. In this case the time axis is the same for all traces so we only need to extract it from the first trace # dt needs to be corrected for the binary setup # All the times are in ms dt = get_header(blocks, \"dt\")[1]/1000 nt = get_header(blocks, \"ns\")[1] T = 0:dt:(nt-1)*dt 0.0:4.0:2000.0 # Midpoint and offset h = (sx .- rx); m = (sx .+ rx)./2; all_m = hcat(m'...)' fold = [sum(all_m .== unique(all_m)[i]) for i=1:length(unique(all_m))]; all_h = hcat(h'...)'; Pick a midpoint Im = findall(all_m .== all_m[1000]) offsets = sort((all_h[Im])); inds = sortperm(all_h[Im]) cmp = Float32.(blocks.data[:, Im[inds]]); figure() imshow(cmp, vmin=-1, vmax=1, cmap=\"Greys\", aspect=3, extent=[offsets[1], offsets[end], T[end], 0]) xlabel(\"offset\") ylabel(\"time\") PyObject Text(24.0, 0.5, 'time') Constant velocity NMO correction nmo_corrected1 = nmo(cmp, 1e-3.*T, offsets, 2000 .+ 0 .*T); figure() imshow(nmo_corrected1, vmin=-1, vmax=1, cmap=\"Greys\", aspect=3, extent=[offsets[1], offsets[end], T[end], 0]) xlabel(\"offset\") ylabel(\"time\") PyObject Text(24.0, 0.5, 'time') Windowing We can see a lot of `artifacts' in the NMO corrected gather above. To avoid some of the artifacts, the midpoint gathers are often windowed to select reflected data only. All events that arrive before the direct wave are removed. A typical window looks like this (Hint: the slope of the triangle is related to the veloctity of the direct wave). # grid tt = [1e-3*ti for ti in T for h in offsets] hh = [h for ti in T for h in offsets] # initialize window to zero and set times later than first arrival to 1. W=0 .*tt;W[tt .> (.1 .+ abs.(hh)./1500)] .= 1 W = reshape(W, size(cmp)[2], size(cmp)[1]) imshow(W', vmin=0, vmax=1, cmap=\"jet\", aspect=3, extent=[offsets[1], offsets[end], T[end], 0]) xlabel(\"offset\") ylabel(\"time\") PyObject Text(24.0, 0.5, 'time') muted = W'.*cmp; figure() imshow(muted, vmin=-1e0, vmax=1e0, cmap=\"Greys\", aspect=3, extent=[offsets[1], offsets[end], T[end], 0]) xlabel(\"offset\") ylabel(\"time\") PyObject Text(24.0, 0.5, 'time') Stack power To figure out which NMO velocity optimally flattens all the events, we can scan through a range of constant NMO velocities and see which events are flattened for which velocity. One way to judge flatness of an event is via the stackpower. The stackpower is just a sum along the offset direction of the values-squared of the NMO-corrected gather: $ S(t_0,v) = \\int!!\\mathrm{d}h\\, d(\\tau(t_0,h,v),h)^2 $ The function $ S(t_0,v) $ is called a semblance panel. The desired NMO velocity can be found by picking the maximum as a function of \\(t_0\\) and \\(v\\) from the semblance panel. An example of a semblance panel and the resulting NMO velocity is shown below. v = 1000:(3000-1000)/(500-1):3000 # scan over velocities S = zeros(length(T),length(v)); for k = 1:length(v) cmp_nmo = nmo(muted, 1e-3.*T, offsets, v[k] .+ 0 .*T); S[:,k] = sum(cmp_nmo .^2, dims = 2); end #Plot semblance panel figure() imshow(S, vmin=0, vmax=1e3, cmap=\"jet\", aspect=1, extent=[v[1], v[end], T[end], 0]) xlabel(\"velocity\") ylabel(\"tau\") PyObject Text(24.0, 0.5, 'tau') # pick v/tau pairs tv = 1e3*[0, 0.30, 0.35, 0.46, 0.65, 1.27, 2.00]; vnmo = [1500, 1500, 1600, 1700, 2000, 2179, 3000]; spl = Spline1D(tv, vnmo; k=1) vnmo_all = spl(T); Look at the velocity profile with the picked tau/v pairs # Enable gui to have the cursor and pick v/tau pairs figure() imshow(S, vmin=0, vmax=1e3, cmap=\"jet\", aspect=1, extent=[v[1], v[end], T[end], 0]) plot(vnmo_all, T, \"-k\") xlabel(\"velocity\") ylabel(\"tau\") PyObject Text(24.0, 0.5, 'tau') nmo_corrected = nmo(muted, 1e-3.*T, offsets, vnmo_all) ; figure() imshow(nmo_corrected, vmin=-1e0, vmax=1e0, cmap=\"Greys\", aspect=3, extent=[offsets[1], offsets[end], T[end], 0]) xlabel(\"offset\") ylabel(\"time\") PyObject Text(24.0, 0.5, 'time') Velocity analysis Repeat the above outline procedure for a couple of mipdoint positions xm (e.g., xm = [500 1000 2000] ). Organize the resulting NMO velocities in a matrix Vm (where column i is the NMO velocity for midpoint xm[i] ) interpolate the results to obtain a velocity for all the midpoints. You can either do Spline1D on every row of Vm , or do Spline2D which interpolates both time T and midpoint position xm . Plot the velocity and discuss. Using this NMO velocity, we can produce an NMO stack. Perform an NMO correction of all the midpoint gathers using the corresponding NMO velocity derived above and sum each along the offset direction. Organize all the stacks in a matrix and plot the result. Also make a stack using a constant NMO velocity. Discuss the results.","title":"NMO correction"},{"location":"Assignments/Exercise2/#nmo-correction","text":"The traveltime as a function of offset of a reflected event can be approximated by the NMO traveltime: $ \\tau(t_0,h) = \\sqrt{t_0 + h 2/v 2} $ where \\((t_0)\\) is the zero-offset or vertical traveltime and \\(v\\) is the effective or NMO velocity. We can now correct the data for the moveout via a simple coordinate transform: $ d_{NMO}(t_0,h) = d(\\tau(t_0,h),h) $ You can use the function nmo implemented below for this exercise. Please download data from Dropbox: https://www.dropbox.com/s/lhjuvaidcttigqg/data.zip?dl=0 Password is exact same with the password which you used to access the lecture note. using Pkg Pkg.add(\"Dierckx\") using Dierckx function nmo(cmp, t, off, v) # NMO correction and adjoint # # use: # out = nmo(in,t,h,v,flag) # # input: # in - data matrix of size [length(t) x length(h)], each column is a trace # t - time vector [s] # offsets - offset vector [m] # v - NMO velocity [m/s] as vector of size [length(t) x 1]. # flag - 1:forward, -1:adjoint # # output # out - data matrix of size [length(t) x length(h)], each column is a trace if size(cmp, 2) == 1 return cmp end # size of data nt, nh = size(cmp) # make sure t and v are column vectors t = t[:] v = v[:] # initialize output out = zeros(nt, nh) # loop over offset for i = 1:nh # NMO traveltime tau = sqrt.(t.^2 + off[i].^2 ./v.^2); # interpolate, forward or adjoint spl = Spline1D(t, cmp[1e-3*T.-t.<1e-5, i]) out[:,i] = spl(tau) end return out end \u001b[32m\u001b[1m Updating\u001b[22m\u001b[39m registry at `~/.julia/registries/General` \u001b[32m\u001b[1m Updating\u001b[22m\u001b[39m git-repo `https://github.com/JuliaRegistries/General.git` \u001b[2K\u001b[?25h[1mFetching:\u001b[22m\u001b[39m [========================================>] 100.0 %.0 %\u001b[32m\u001b[1m Resolving\u001b[22m\u001b[39m package versions... \u001b[32m\u001b[1m Updating\u001b[22m\u001b[39m `~/.julia/environments/v1.2/Project.toml` \u001b[90m [no changes]\u001b[39m \u001b[32m\u001b[1m Updating\u001b[22m\u001b[39m `~/.julia/environments/v1.2/Manifest.toml` \u001b[90m [no changes]\u001b[39m nmo (generic function with 1 method) using SegyIO, PyPlot # read the dataset blocks = segy_read(\"/home/yzhang3198/Downloads/data_segy/cube2.segy\"); \u250c Warning: Fixed length trace flag set in stream: IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=90663444, maxsize=Inf, ptr=3601, mark=-1) \u2514 @ SegyIO /home/yzhang3198/.julia/packages/SegyIO/ak2qG/src/read/read_file.jl:26 sx = get_header(blocks, \"SourceX\";scale=false) rx = get_header(blocks, \"GroupX\";scale=false); # Get the time axis. In this case the time axis is the same for all traces so we only need to extract it from the first trace # dt needs to be corrected for the binary setup # All the times are in ms dt = get_header(blocks, \"dt\")[1]/1000 nt = get_header(blocks, \"ns\")[1] T = 0:dt:(nt-1)*dt 0.0:4.0:2000.0 # Midpoint and offset h = (sx .- rx); m = (sx .+ rx)./2; all_m = hcat(m'...)' fold = [sum(all_m .== unique(all_m)[i]) for i=1:length(unique(all_m))]; all_h = hcat(h'...)';","title":"NMO correction"},{"location":"Assignments/Exercise2/#pick-a-midpoint","text":"Im = findall(all_m .== all_m[1000]) offsets = sort((all_h[Im])); inds = sortperm(all_h[Im]) cmp = Float32.(blocks.data[:, Im[inds]]); figure() imshow(cmp, vmin=-1, vmax=1, cmap=\"Greys\", aspect=3, extent=[offsets[1], offsets[end], T[end], 0]) xlabel(\"offset\") ylabel(\"time\") PyObject Text(24.0, 0.5, 'time')","title":"Pick a midpoint"},{"location":"Assignments/Exercise2/#constant-velocity-nmo-correction","text":"nmo_corrected1 = nmo(cmp, 1e-3.*T, offsets, 2000 .+ 0 .*T); figure() imshow(nmo_corrected1, vmin=-1, vmax=1, cmap=\"Greys\", aspect=3, extent=[offsets[1], offsets[end], T[end], 0]) xlabel(\"offset\") ylabel(\"time\") PyObject Text(24.0, 0.5, 'time')","title":"Constant velocity NMO correction"},{"location":"Assignments/Exercise2/#windowing","text":"We can see a lot of `artifacts' in the NMO corrected gather above. To avoid some of the artifacts, the midpoint gathers are often windowed to select reflected data only. All events that arrive before the direct wave are removed. A typical window looks like this (Hint: the slope of the triangle is related to the veloctity of the direct wave). # grid tt = [1e-3*ti for ti in T for h in offsets] hh = [h for ti in T for h in offsets] # initialize window to zero and set times later than first arrival to 1. W=0 .*tt;W[tt .> (.1 .+ abs.(hh)./1500)] .= 1 W = reshape(W, size(cmp)[2], size(cmp)[1]) imshow(W', vmin=0, vmax=1, cmap=\"jet\", aspect=3, extent=[offsets[1], offsets[end], T[end], 0]) xlabel(\"offset\") ylabel(\"time\") PyObject Text(24.0, 0.5, 'time') muted = W'.*cmp; figure() imshow(muted, vmin=-1e0, vmax=1e0, cmap=\"Greys\", aspect=3, extent=[offsets[1], offsets[end], T[end], 0]) xlabel(\"offset\") ylabel(\"time\") PyObject Text(24.0, 0.5, 'time')","title":"Windowing"},{"location":"Assignments/Exercise2/#stack-power","text":"To figure out which NMO velocity optimally flattens all the events, we can scan through a range of constant NMO velocities and see which events are flattened for which velocity. One way to judge flatness of an event is via the stackpower. The stackpower is just a sum along the offset direction of the values-squared of the NMO-corrected gather: $ S(t_0,v) = \\int!!\\mathrm{d}h\\, d(\\tau(t_0,h,v),h)^2 $ The function $ S(t_0,v) $ is called a semblance panel. The desired NMO velocity can be found by picking the maximum as a function of \\(t_0\\) and \\(v\\) from the semblance panel. An example of a semblance panel and the resulting NMO velocity is shown below. v = 1000:(3000-1000)/(500-1):3000 # scan over velocities S = zeros(length(T),length(v)); for k = 1:length(v) cmp_nmo = nmo(muted, 1e-3.*T, offsets, v[k] .+ 0 .*T); S[:,k] = sum(cmp_nmo .^2, dims = 2); end #Plot semblance panel figure() imshow(S, vmin=0, vmax=1e3, cmap=\"jet\", aspect=1, extent=[v[1], v[end], T[end], 0]) xlabel(\"velocity\") ylabel(\"tau\") PyObject Text(24.0, 0.5, 'tau') # pick v/tau pairs tv = 1e3*[0, 0.30, 0.35, 0.46, 0.65, 1.27, 2.00]; vnmo = [1500, 1500, 1600, 1700, 2000, 2179, 3000]; spl = Spline1D(tv, vnmo; k=1) vnmo_all = spl(T);","title":"Stack power"},{"location":"Assignments/Exercise2/#look-at-the-velocity-profile-with-the-picked-tauv-pairs","text":"# Enable gui to have the cursor and pick v/tau pairs figure() imshow(S, vmin=0, vmax=1e3, cmap=\"jet\", aspect=1, extent=[v[1], v[end], T[end], 0]) plot(vnmo_all, T, \"-k\") xlabel(\"velocity\") ylabel(\"tau\") PyObject Text(24.0, 0.5, 'tau') nmo_corrected = nmo(muted, 1e-3.*T, offsets, vnmo_all) ; figure() imshow(nmo_corrected, vmin=-1e0, vmax=1e0, cmap=\"Greys\", aspect=3, extent=[offsets[1], offsets[end], T[end], 0]) xlabel(\"offset\") ylabel(\"time\") PyObject Text(24.0, 0.5, 'time')","title":"Look at the velocity profile with the picked tau/v pairs"},{"location":"Assignments/Exercise2/#velocity-analysis","text":"Repeat the above outline procedure for a couple of mipdoint positions xm (e.g., xm = [500 1000 2000] ). Organize the resulting NMO velocities in a matrix Vm (where column i is the NMO velocity for midpoint xm[i] ) interpolate the results to obtain a velocity for all the midpoints. You can either do Spline1D on every row of Vm , or do Spline2D which interpolates both time T and midpoint position xm . Plot the velocity and discuss. Using this NMO velocity, we can produce an NMO stack. Perform an NMO correction of all the midpoint gathers using the corresponding NMO velocity derived above and sum each along the offset direction. Organize all the stacks in a matrix and plot the result. Also make a stack using a constant NMO velocity. Discuss the results.","title":"Velocity analysis"},{"location":"Assignments/Exercise3/","text":"Homework 3: wavefield extrapolation and migration Contents: - Wavefield extrapolation - Zero-offset migration - Prestack migration - Wavefield extrapolation For a constant-velocity medium, we can extrapolate a wavefield at depth \\(z\\) to depth \\(z+\\Delta z\\) via a simple phase shift in the \\(f-k\\) domain: \\(u(\\omega,k,z + \\Delta z) = u(\\omega,k,z)\\exp[\\imath\\Delta z\\sqrt{\\omega^2/v^2 - k^2}]\\) To illustrate this, we generate a source wavefield in the \\(t-x\\) domain and extrapolate it. First, let's define an impulsive source. using PyPlot using FFTW f-k domain transform function fktran function fktran(a,t,x,mode) \"\"\" f-k transform for real-values input. use: b, f, k = fktran(a,t,x,mode) input: a - matrix in t-x domain (nt x nx) t - time vector x - x vector mode - 1:forward, -1:inverse \"\"\" nt = length(t) nx = length(x) dt = t[2]-t[1] dx = x[2] - x[1] xmax = x[end] - x[1] tmax = t[end] - t[1] f = 0:1/tmax:.5/dt k = -.5/dx:1/xmax:.5/dx nf = length(f) if mode == 1 b = fft(a, 1) b = b[1:nf, :] b = ifft(b, 2) b = circshift(b,[0 ceil(Int, nx/2)-1]); elseif mode == -1 b = circshift(a,[0 floor(Int, nx/2)+1]); b = fft(b, 2) b = ifft(b, 1) b = real(b) else error(\"unknown mode\") end return b, f, k end fktran (generic function with 1 method) # time coordinate in seconds as column vector t = 0:.004:1; # spatial coordinate in meters as row vector x = 0:10:1000; # generate 2D grid: tt = [ti for ti in t, xi in x]; xx = [xi for ti in t, xi in x]; # Source wavefield is impulsive source at t=0.1 and x=500, source = (tt .- .1).*exp.(-1e-3*(xx.-500).^2 .- 1e3*(tt .-.1).^2); # plot it imshow(source, cmap=\"Greys\", extent=[x[1], x[end], t[end], t[1]], aspect=500) xlabel(\"x [m]\") ylabel(\"t [s]\") title(\"wavefield at z=0 m.\") PyObject Text(0.5, 1, 'wavefield at z=0 m.') # now, transform it to the f-k domain using fktran source_fk, f, k = fktran(source,t,x,1); Next, we define the extrapolation factor and plot it. # generate a grid for f,k ff = [fi for fi in f, ki in k] kk = [ki for fi in f, ki in k] # the extrapolation factor for a velocity v is defined as follows # (note the factor \\(2 pi\\) to go from frequency to wavenumber) v = 2000 dz = 10 kz = 2*pi*sqrt.(complex.((ff./v).^2 - kk.^2)) W = exp.(dz*im.*kz) # now plot absolute value for 10 Hz plot(k,abs.(W[ff.==10])) xlabel(\"k [1/m]\");ylabel(\"|W|\");title(\"|W| @ 10 Hz.\"); The region where the extrapolation factor is smaller than one is called the evanescent region. Waves this these wavenumbers will be damped. We have to be carefull with the sign of \\(k_z\\) in the exponentional factor and make sure that the absolute value is always smaller than one. The wavefield at z = 500 m looks like # fix sign of kz kz = -real(kz)+im*abs.(imag(kz)); W = exp.(500*im.*kz); # extrapolate and transform back to t-x source_extrap, _, _ = fktran(W.*source_fk,t,x,-1); #plot imshow(real(source_extrap), cmap=\"Greys\", vmin=-.1e-2, vmax=.1e-2, extent=[x[1], x[end], t[end], t[1]], aspect=700) xlabel(\"x [m]\") ylabel(\"t [s]\") title(\"wavefield at z=500 m.\") PyObject Text(0.5, 1, 'wavefield at z=500 m.') Questions What happens if the imaginary part of kz has the wrong sign? try it. same for the real part. What does the extrapolator look like in the t-x domain? How can you extraplotate the wavefield in the t-x domain directly using the extrapolator in the t-x domain? Zero-offset migration In this part of the exercise we look at zero-offset migration. This type of migration is based on the \"exploding-reflector\" concept. Zero-offset migration can be done by exptrapolating the zero-offset data with half-velocity and taking the image to be slice of the wavefield at \\(t=0\\) for each depth step: \\(I(z,x) = u(z,x,t=0)\\) The function wave_extrap.m takes in a wavefield u and the correspoding time/space vectors t,x, a velocity v, a depth step dz and a propagation direction dir and extrapolates the input wavefield. Load the zero-offset data data1_zero.segy and define the source, receiver and time coordinates. The units of the source and receiver coordinates are in meters for this file. The data looks like this using SegyIO # Dowload and adapt path run(`wget https://www.dropbox.com/s/7otrsjstdlrk5k4/data1_zo.segy`) shot = segy_read(pwd()*\"/data1_zo.segy\") shot_data = Float32.(shot.data) sx = get_header(shot, \"SourceX\", scale=false) dt = get_header(shot, \"dt\")[1]/1e6 nt = get_header(shot, \"ns\")[1] T = 0:dt:(nt -1)*dt \u250c Warning: Fixed length trace flag set in stream: IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=253644, maxsize=Inf, ptr=3601, mark=-1) \u2514 @ SegyIO /home/yzhang3198/.julia/packages/SegyIO/ak2qG/src/read/read_file.jl:26 0.0:0.004:1.0 imshow(shot_data, vmin=-.1, vmax=.1, cmap=\"Greys\", extent=[sx[1], sx[end], T[end], T[1]], aspect=1000) xlabel(\"source position [m]\") ylabel(\"t [s]\") PyObject Text(24.000000000000007, 0.5, 't [s]') Use the function wave_extrap to migrate the zero offset section. A reasonable depth axis is z = 0:5:1000. Use the source position as lateral position x. The correct velocity is v0 = 2000 km/s (but, remember this is zero-offset migration so adapt the velocity accordingly!). A zero-offset migration can done as follows: function wave_extrap(u,t,x,v,dz,dir) # wavefield extrapolation by phase shift # # use: # v = wave_extrap(u,t,x,v,dz,dir) # # input: # u - wavefield as matrix of size length(t) x length(x) # t - time coordinates in seconds as column vector # x - space coordinates in meters as row vector # v - velocity in m/s (scalar) # dz - depth step in meters # dir - 1: forward in time, -1 backward in time # # output: # v - extrapolated wavefield # # fk transform of the wavefield spec, f, k = fktran(u, t, x, 1) # define grid and kz ff = [fi for fi in f, ki in k] kk = [ki for fi in f, ki in k] kz = 2*pi*sqrt.(complex((ff/v).^2-kk.^2)) # set sign of real part of kz kz = -sign.(dir)*real(kz)+im*abs.(imag(kz)) # apply phase shift spec = exp.(im*abs.(dz).*kz).*spec # inverse fk transform v, _, _ = fktran(spec, f, k, -1) # take real part of wavefield v = real(v) return v end wave_extrap (generic function with 1 method) # depth axis z = 0:5:1000 dz = 5 # velocity v = 2000 # migrate for correct velocity migcorr = zeros(length(z),length(sx)) for k = 1:length(z) tmp = wave_extrap(shot_data, T, sx, v./2, z[k], -1) migcorr[k, :] = tmp[1, :] end # plot it imshow(migcorr, cmap=\"Greys\", vmin=-.1, vmax=.1, extent=[sx[1], sx[end], z[end], z[1]], aspect=1) xlabel(\"x [m]\") ylabel(\"z [m]\") title(\"correct velocity\") PyObject Text(0.5, 1, 'correct velocity') Questions Compare the migrated result to the zero-offset section. What do you notice? For easier comparison, you might want to transform the time axis into depth using the correct velocity. Do a zero-offset migration for too low and too high velocities. What do you notice? Repeat the same exercise for data2_zo.su. What do you notice here? Prestack migration We can also create an image by extrapolating the source wavefields and the data and correlating them at different depth levels. Read the data data_ex3.segy run(`wget https://www.dropbox.com/s/hotb48jaf3ksve5/data_ex3.segy`) block = segy_read(pwd()*\"/data_ex3.segy\") sx = get_header(block, \"SourceX\", scale=false) rx = get_header(block, \"GroupX\", scale=false) dt = get_header(block, \"dt\")[1]/1e6 nt = get_header(block, \"ns\")[1] T = 0:dt:(nt -1)*dt # unique src/rec locations xs = unique(sx) xr = unique(rx); \u250c Warning: Fixed length trace flag set in stream: IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=1385684, maxsize=Inf, ptr=3601, mark=-1) \u2514 @ SegyIO /home/yzhang3198/.julia/packages/SegyIO/ak2qG/src/read/read_file.jl:26 We extrapolate both source and receiver wavefields for one shot using wave_extrap (see comments in wave_extrap for documenation) and plot them side-by-side: # velocity v = 2000; # t-x grid tt = [ti for ti in T, xi in xr]; xx = [xi for ti in T, xi in xr]; # choose shot 6 is = 6 # source wavefield at z=0 source = (tt .-.1).*exp.(-1e-3*(xx .-xs[is]).^2 .- 1e3*(tt .-.1).^2); # receiver wavefield is data for corresponding shot receiver = Float32.(block.data[:, sx.==xs[is]]); imshow(wave_extrap(source,t,xr,v,500,1), cmap=\"Greys\", vmin=-.001, vmax=.001, extent=[xr[1], xr[end], T[end], T[1]], aspect=500) xlabel(\"x [m]\") ylabel(\"t [s]\") title(\"source wavefield at z=500 m.\") figure() imshow(wave_extrap(receiver,t,xr,v,500,-1), cmap=\"Greys\", vmin=-1, vmax=1, extent=[xr[1], xr[end], T[end], T[1]], aspect=500) xlabel(\"x [m]\") ylabel(\"t [s]\") title(\"receiver wavefield at z=500 m.\") PyObject Text(0.5, 1, 'receiver wavefield at z=500 m.') Question Extrapolate both source and receiver wavefields to differents depths. What do you notice? An image of the reflector can be constructed by correlating the two wavefields at zero time-lag (basically summing over time) # velocity v = 2e3 # depth dz = 10 z = 0:dz:1000 # initialize image image = zeros(length(z),length(xr)) # loop for iz = 1:length(z) shoti = wave_extrap(source, T, xr, v, z[iz], 1) reci = wave_extrap(receiver, T, xr, v, z[iz], -1) image[iz,:] = sum(shoti .* reci, dims = 1) end figure() imshow(image, cmap=\"Greys\", vmin=-1e-2, vmax=1e-2, extent=[xr[1], xr[end], z[end], z[1]], aspect=1) xlabel(\"x [m]\") ylabel(\"z [m]\") title(\"image for one source\") PyObject Text(0.5, 1, 'image for one source') Questions Use the template mig_extrap below and implement migration of multiple shots based on the above outlined algorithm by filling in the gaps. You can call wave_extrap as subroutine. Use mig_extrap.m for the following exercises. Migrate a single shot for velocities that are too low and too high (say 10 percent). What do you see? Repeat this for all sources and sum the images for all sources, again also for too low/high velocity. What do you see? Describe how you would adapt the migration algorithm for a velocity that varies with depth. function mig_extrap(data, t, xr, xs, z, v) # # shot-receiver migration for constant velocity by wavefield extrapolation. # # use: # image = mig_extrap(data,t,xr,xs,v) # # input: # data - data cube of size length(t) x length(xr) x length(xs) # t - time coordinate in seconds as column vector # xr - receiver coordinate in meters as row vector # xs - source coordinate in meters as row vector # z - depth coordinate in meters as column vector # v - velocity in m/s (scalar) # # output: # image - image as matrix of size length(z) x length(xr) # initialize image image = zeros(length(z),length(xr)); # depth step dz = z[2] - z[1] # t-x grid tt = [ti for ti in t, xi in xr] xx = [xi for ti in t, xi in xr] # loop over shots for is = 1:length(xs) # construct impulsive source at source location source = (tt-.1).*exp.(-1e-3*(xx-xs[is]).^2 - 1e3*(tt-.1).^2); # select data beloning to source is receiver = # loop over depth levels for iz = 1:length(z) # use wave_extrap to advance both wavefields one depthlevel srci = reci = # update image image[iz,:] = image[iz,:] + end # end loop over depth levels end # end loop over shots return image end","title":"Homework 3: wavefield extrapolation and migration"},{"location":"Assignments/Exercise3/#homework-3-wavefield-extrapolation-and-migration","text":"Contents: - Wavefield extrapolation - Zero-offset migration - Prestack migration - Wavefield extrapolation For a constant-velocity medium, we can extrapolate a wavefield at depth \\(z\\) to depth \\(z+\\Delta z\\) via a simple phase shift in the \\(f-k\\) domain: \\(u(\\omega,k,z + \\Delta z) = u(\\omega,k,z)\\exp[\\imath\\Delta z\\sqrt{\\omega^2/v^2 - k^2}]\\) To illustrate this, we generate a source wavefield in the \\(t-x\\) domain and extrapolate it. First, let's define an impulsive source. using PyPlot using FFTW","title":"Homework 3: wavefield extrapolation and migration"},{"location":"Assignments/Exercise3/#f-k-domain-transform-function-fktran","text":"function fktran(a,t,x,mode) \"\"\" f-k transform for real-values input. use: b, f, k = fktran(a,t,x,mode) input: a - matrix in t-x domain (nt x nx) t - time vector x - x vector mode - 1:forward, -1:inverse \"\"\" nt = length(t) nx = length(x) dt = t[2]-t[1] dx = x[2] - x[1] xmax = x[end] - x[1] tmax = t[end] - t[1] f = 0:1/tmax:.5/dt k = -.5/dx:1/xmax:.5/dx nf = length(f) if mode == 1 b = fft(a, 1) b = b[1:nf, :] b = ifft(b, 2) b = circshift(b,[0 ceil(Int, nx/2)-1]); elseif mode == -1 b = circshift(a,[0 floor(Int, nx/2)+1]); b = fft(b, 2) b = ifft(b, 1) b = real(b) else error(\"unknown mode\") end return b, f, k end fktran (generic function with 1 method) # time coordinate in seconds as column vector t = 0:.004:1; # spatial coordinate in meters as row vector x = 0:10:1000; # generate 2D grid: tt = [ti for ti in t, xi in x]; xx = [xi for ti in t, xi in x]; # Source wavefield is impulsive source at t=0.1 and x=500, source = (tt .- .1).*exp.(-1e-3*(xx.-500).^2 .- 1e3*(tt .-.1).^2); # plot it imshow(source, cmap=\"Greys\", extent=[x[1], x[end], t[end], t[1]], aspect=500) xlabel(\"x [m]\") ylabel(\"t [s]\") title(\"wavefield at z=0 m.\") PyObject Text(0.5, 1, 'wavefield at z=0 m.') # now, transform it to the f-k domain using fktran source_fk, f, k = fktran(source,t,x,1); Next, we define the extrapolation factor and plot it. # generate a grid for f,k ff = [fi for fi in f, ki in k] kk = [ki for fi in f, ki in k] # the extrapolation factor for a velocity v is defined as follows # (note the factor \\(2 pi\\) to go from frequency to wavenumber) v = 2000 dz = 10 kz = 2*pi*sqrt.(complex.((ff./v).^2 - kk.^2)) W = exp.(dz*im.*kz) # now plot absolute value for 10 Hz plot(k,abs.(W[ff.==10])) xlabel(\"k [1/m]\");ylabel(\"|W|\");title(\"|W| @ 10 Hz.\"); The region where the extrapolation factor is smaller than one is called the evanescent region. Waves this these wavenumbers will be damped. We have to be carefull with the sign of \\(k_z\\) in the exponentional factor and make sure that the absolute value is always smaller than one. The wavefield at z = 500 m looks like # fix sign of kz kz = -real(kz)+im*abs.(imag(kz)); W = exp.(500*im.*kz); # extrapolate and transform back to t-x source_extrap, _, _ = fktran(W.*source_fk,t,x,-1); #plot imshow(real(source_extrap), cmap=\"Greys\", vmin=-.1e-2, vmax=.1e-2, extent=[x[1], x[end], t[end], t[1]], aspect=700) xlabel(\"x [m]\") ylabel(\"t [s]\") title(\"wavefield at z=500 m.\") PyObject Text(0.5, 1, 'wavefield at z=500 m.')","title":"f-k domain transform function fktran"},{"location":"Assignments/Exercise3/#questions","text":"What happens if the imaginary part of kz has the wrong sign? try it. same for the real part. What does the extrapolator look like in the t-x domain? How can you extraplotate the wavefield in the t-x domain directly using the extrapolator in the t-x domain?","title":"Questions"},{"location":"Assignments/Exercise3/#zero-offset-migration","text":"In this part of the exercise we look at zero-offset migration. This type of migration is based on the \"exploding-reflector\" concept. Zero-offset migration can be done by exptrapolating the zero-offset data with half-velocity and taking the image to be slice of the wavefield at \\(t=0\\) for each depth step: \\(I(z,x) = u(z,x,t=0)\\) The function wave_extrap.m takes in a wavefield u and the correspoding time/space vectors t,x, a velocity v, a depth step dz and a propagation direction dir and extrapolates the input wavefield. Load the zero-offset data data1_zero.segy and define the source, receiver and time coordinates. The units of the source and receiver coordinates are in meters for this file. The data looks like this using SegyIO # Dowload and adapt path run(`wget https://www.dropbox.com/s/7otrsjstdlrk5k4/data1_zo.segy`) shot = segy_read(pwd()*\"/data1_zo.segy\") shot_data = Float32.(shot.data) sx = get_header(shot, \"SourceX\", scale=false) dt = get_header(shot, \"dt\")[1]/1e6 nt = get_header(shot, \"ns\")[1] T = 0:dt:(nt -1)*dt \u250c Warning: Fixed length trace flag set in stream: IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=253644, maxsize=Inf, ptr=3601, mark=-1) \u2514 @ SegyIO /home/yzhang3198/.julia/packages/SegyIO/ak2qG/src/read/read_file.jl:26 0.0:0.004:1.0 imshow(shot_data, vmin=-.1, vmax=.1, cmap=\"Greys\", extent=[sx[1], sx[end], T[end], T[1]], aspect=1000) xlabel(\"source position [m]\") ylabel(\"t [s]\") PyObject Text(24.000000000000007, 0.5, 't [s]') Use the function wave_extrap to migrate the zero offset section. A reasonable depth axis is z = 0:5:1000. Use the source position as lateral position x. The correct velocity is v0 = 2000 km/s (but, remember this is zero-offset migration so adapt the velocity accordingly!). A zero-offset migration can done as follows: function wave_extrap(u,t,x,v,dz,dir) # wavefield extrapolation by phase shift # # use: # v = wave_extrap(u,t,x,v,dz,dir) # # input: # u - wavefield as matrix of size length(t) x length(x) # t - time coordinates in seconds as column vector # x - space coordinates in meters as row vector # v - velocity in m/s (scalar) # dz - depth step in meters # dir - 1: forward in time, -1 backward in time # # output: # v - extrapolated wavefield # # fk transform of the wavefield spec, f, k = fktran(u, t, x, 1) # define grid and kz ff = [fi for fi in f, ki in k] kk = [ki for fi in f, ki in k] kz = 2*pi*sqrt.(complex((ff/v).^2-kk.^2)) # set sign of real part of kz kz = -sign.(dir)*real(kz)+im*abs.(imag(kz)) # apply phase shift spec = exp.(im*abs.(dz).*kz).*spec # inverse fk transform v, _, _ = fktran(spec, f, k, -1) # take real part of wavefield v = real(v) return v end wave_extrap (generic function with 1 method) # depth axis z = 0:5:1000 dz = 5 # velocity v = 2000 # migrate for correct velocity migcorr = zeros(length(z),length(sx)) for k = 1:length(z) tmp = wave_extrap(shot_data, T, sx, v./2, z[k], -1) migcorr[k, :] = tmp[1, :] end # plot it imshow(migcorr, cmap=\"Greys\", vmin=-.1, vmax=.1, extent=[sx[1], sx[end], z[end], z[1]], aspect=1) xlabel(\"x [m]\") ylabel(\"z [m]\") title(\"correct velocity\") PyObject Text(0.5, 1, 'correct velocity')","title":"Zero-offset migration"},{"location":"Assignments/Exercise3/#questions_1","text":"Compare the migrated result to the zero-offset section. What do you notice? For easier comparison, you might want to transform the time axis into depth using the correct velocity. Do a zero-offset migration for too low and too high velocities. What do you notice? Repeat the same exercise for data2_zo.su. What do you notice here?","title":"Questions"},{"location":"Assignments/Exercise3/#prestack-migration","text":"We can also create an image by extrapolating the source wavefields and the data and correlating them at different depth levels. Read the data data_ex3.segy run(`wget https://www.dropbox.com/s/hotb48jaf3ksve5/data_ex3.segy`) block = segy_read(pwd()*\"/data_ex3.segy\") sx = get_header(block, \"SourceX\", scale=false) rx = get_header(block, \"GroupX\", scale=false) dt = get_header(block, \"dt\")[1]/1e6 nt = get_header(block, \"ns\")[1] T = 0:dt:(nt -1)*dt # unique src/rec locations xs = unique(sx) xr = unique(rx); \u250c Warning: Fixed length trace flag set in stream: IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=1385684, maxsize=Inf, ptr=3601, mark=-1) \u2514 @ SegyIO /home/yzhang3198/.julia/packages/SegyIO/ak2qG/src/read/read_file.jl:26 We extrapolate both source and receiver wavefields for one shot using wave_extrap (see comments in wave_extrap for documenation) and plot them side-by-side: # velocity v = 2000; # t-x grid tt = [ti for ti in T, xi in xr]; xx = [xi for ti in T, xi in xr]; # choose shot 6 is = 6 # source wavefield at z=0 source = (tt .-.1).*exp.(-1e-3*(xx .-xs[is]).^2 .- 1e3*(tt .-.1).^2); # receiver wavefield is data for corresponding shot receiver = Float32.(block.data[:, sx.==xs[is]]); imshow(wave_extrap(source,t,xr,v,500,1), cmap=\"Greys\", vmin=-.001, vmax=.001, extent=[xr[1], xr[end], T[end], T[1]], aspect=500) xlabel(\"x [m]\") ylabel(\"t [s]\") title(\"source wavefield at z=500 m.\") figure() imshow(wave_extrap(receiver,t,xr,v,500,-1), cmap=\"Greys\", vmin=-1, vmax=1, extent=[xr[1], xr[end], T[end], T[1]], aspect=500) xlabel(\"x [m]\") ylabel(\"t [s]\") title(\"receiver wavefield at z=500 m.\") PyObject Text(0.5, 1, 'receiver wavefield at z=500 m.')","title":"Prestack migration"},{"location":"Assignments/Exercise3/#question","text":"Extrapolate both source and receiver wavefields to differents depths. What do you notice? An image of the reflector can be constructed by correlating the two wavefields at zero time-lag (basically summing over time) # velocity v = 2e3 # depth dz = 10 z = 0:dz:1000 # initialize image image = zeros(length(z),length(xr)) # loop for iz = 1:length(z) shoti = wave_extrap(source, T, xr, v, z[iz], 1) reci = wave_extrap(receiver, T, xr, v, z[iz], -1) image[iz,:] = sum(shoti .* reci, dims = 1) end figure() imshow(image, cmap=\"Greys\", vmin=-1e-2, vmax=1e-2, extent=[xr[1], xr[end], z[end], z[1]], aspect=1) xlabel(\"x [m]\") ylabel(\"z [m]\") title(\"image for one source\") PyObject Text(0.5, 1, 'image for one source')","title":"Question"},{"location":"Assignments/Exercise3/#questions_2","text":"Use the template mig_extrap below and implement migration of multiple shots based on the above outlined algorithm by filling in the gaps. You can call wave_extrap as subroutine. Use mig_extrap.m for the following exercises. Migrate a single shot for velocities that are too low and too high (say 10 percent). What do you see? Repeat this for all sources and sum the images for all sources, again also for too low/high velocity. What do you see? Describe how you would adapt the migration algorithm for a velocity that varies with depth. function mig_extrap(data, t, xr, xs, z, v) # # shot-receiver migration for constant velocity by wavefield extrapolation. # # use: # image = mig_extrap(data,t,xr,xs,v) # # input: # data - data cube of size length(t) x length(xr) x length(xs) # t - time coordinate in seconds as column vector # xr - receiver coordinate in meters as row vector # xs - source coordinate in meters as row vector # z - depth coordinate in meters as column vector # v - velocity in m/s (scalar) # # output: # image - image as matrix of size length(z) x length(xr) # initialize image image = zeros(length(z),length(xr)); # depth step dz = z[2] - z[1] # t-x grid tt = [ti for ti in t, xi in xr] xx = [xi for ti in t, xi in xr] # loop over shots for is = 1:length(xs) # construct impulsive source at source location source = (tt-.1).*exp.(-1e-3*(xx-xs[is]).^2 - 1e3*(tt-.1).^2); # select data beloning to source is receiver = # loop over depth levels for iz = 1:length(z) # use wave_extrap to advance both wavefields one depthlevel srci = reci = # update image image[iz,:] = image[iz,:] + end # end loop over depth levels end # end loop over shots return image end","title":"Questions"},{"location":"Assignments/Exercise4/","text":"Exercise 4: Fourier and Radon filtering In this exercise we will look at seismic data in different domains and investigate how we can exploit behaviour of different kinds of noise in these domains to design filters. Contents: - Data - Temporal Fourier transform - f-k filtering - Radon transform - Parabolic Radon transform using PyPlot, SegyIO, FFTW Data We use a single midpoint gather of the data used in the previous exercises: shot.segy (no big endian this time). # Dowload and adapt path shot = segy_read(\"/home/yzhang3198/Downloads/data_segy/shot.segy\") shot_data = Float32.(shot.data) h = get_header(shot, \"SourceX\", scale=false) - get_header(shot, \"GroupX\", scale=false) dt = get_header(shot, \"dt\")[1]/1e6 nt = get_header(shot, \"ns\")[1] T = 0:dt:(nt -1)*dt \u250c Warning: Fixed length trace flag set in stream: IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=1705444, maxsize=Inf, ptr=3601, mark=-1) \u2514 @ SegyIO /home/yzhang3198/.julia/packages/SegyIO/ak2qG/src/read/read_file.jl:26 0.0:0.004:4.0 imshow(shot_data, vmin=-1, vmax=1, cmap=\"Greys\", extent=[h[end], h[1], T[end], T[1]], aspect=1000) xlabel(\"offset [m]\");ylabel(\"time [s]\"); Temporal Fourier transform We can use fftrl to perform a Fourier transform along the temporal direction. The power spectrum (i.e., the absolute value of the transformed data) looks like function fftrl(a, t, mode) # fft for real-valued vectors # # Tristan van Leeuwen, 2012 # tleeuwen@eos.ubc.ca # # use: # [b,f] = fftrl(a,t,mode) # # input: # a - input data # t - time vector # mode: 1: forward, -1:inverse # # output: # b - vector nt = length(t) dt = t[2] - t[1] nf = Int(floor(nt/2)) + 1 tmax = t[end] - t[1] f = 0:1/tmax:.5/dt if mode == 1 b = fft(a,1) b = b[1:nf,:] elseif mode == -1 a = [a;conj(a[Int(ceil(nt/2)):-1:2,:])] b = ifft(a, 1) b = real(b) else error(\"Unknown mode\") end return b, f end fftrl (generic function with 1 method) Data_fh, f = fftrl(shot_data, T, 1) (Complex{Float32}[0.6844337f0 + 0.0f0im 0.9717815f0 + 0.0f0im \u2026 0.09694278f0 + 0.0f0im 0.004332781f0 + 0.0f0im; -0.70118594f0 - 0.4517814f0im -0.41232893f0 - 0.46060145f0im \u2026 -1.3077996f0 - 0.49731374f0im -1.4023542f0 - 0.48800778f0im; \u2026 ; -0.121281974f0 + 0.0007099677f0im -0.08637722f0 - 0.00040336605f0im \u2026 0.1578058f0 - 0.0011496469f0im 0.11014599f0 - 0.0002730284f0im; -0.12202144f0 + 0.00059955195f0im -0.08491863f0 - 0.00023266952f0im \u2026 0.15901898f0 - 0.0005980283f0im 0.10969794f0 - 0.00018512644f0im], 0.0:0.25:125.0) imshow(abs.(Data_fh), cmap=\"jet\", extent=[h[end], h[1], f[end], f[1]], aspect=20) xlabel(\"offset [m]\");ylabel(\"frequency [Hz]\") PyObject Text(24.000000000000007, 0.5, 'frequency [Hz]') f-k filtering A Fourier transform along both time and offset direction is often referred to as an transform. We can use fktran. The powerspectrum looks like function fktran(a,t,x,mode) \"\"\" f-k transform for real-values input. use: b, f, k = fktran(a,t,x,mode) input: a - matrix in t-x domain (nt x nx) t - time vector x - x vector mode - 1:forward, -1:inverse \"\"\" nt = length(t) nx = length(x) dt = t[2]-t[1] dx = x[2] - x[1] xmax = x[end] - x[1] tmax = t[end] - t[1] f = 0:1/tmax:.5/dt k = -.5/dx:1/xmax:.5/dx nf = length(f) if mode == 1 b = fft(a, 1) b = b[1:nf, :] b = ifft(b, 2) b = circshift(b,[0 ceil(Int, nx/2)-1]); elseif mode == -1 b = circshift(a,[0 floor(Int, nx/2)+1]); b = fft(b, 2) b = ifft([b;conj(b[end:-1:2,:])], 1) b = real(b) else error(\"unknown mode\") end return b, f, k end fktran (generic function with 1 method) Data_fk, fk, kx = fktran(shot_data, T, h, 1) (Complex{Float32}[0.002173217f0 + 0.37586603f0im -0.003716143f0 - 0.37589622f0im \u2026 -0.0037163715f0 + 0.37589744f0im 0.0021728363f0 - 0.37586543f0im; -0.06664165f0 + 0.37817085f0im 0.06513726f0 - 0.37864232f0im \u2026 -0.072564445f0 + 0.37711513f0im 0.07105575f0 - 0.37754175f0im; \u2026 ; 0.0033008547f0 + 0.40090138f0im -0.006969956f0 - 0.40087533f0im \u2026 -0.002999703f0 + 0.40091997f0im -0.0006929431f0 - 0.40090662f0im; 0.0019657868f0 + 0.40089262f0im -0.0056476546f0 - 0.4009117f0im \u2026 -0.0043306802f0 + 0.4009047f0im 0.000641849f0 - 0.4008996f0im], 0.0:0.25:125.0, 0.05:-0.00025:-0.05) imshow(abs.(Data_fk), cmap=\"jet\", extent=[kx[end], kx[1], f[end], f[1]], aspect=.001) xlabel(\"wavenumber [1/m\");ylabel(\"frequency [Hz]\") PyObject Text(23.999999999999993, 0.5, 'frequency [Hz]') back, _, _ = fktran(Data_fk, fk, kx, -1) imshow(back, vmin=-1, vmax=1, cmap=\"Greys\", extent=[h[end], h[1], T[end], T[1]], aspect=1000) xlabel(\"offset [m]\");ylabel(\"time [s]\"); size(shot_data) (1001, 401) Questions: Subsample the data in the offset direction and look at the Fourier transform. (Hint: use Data[:,1:n:end] and h[1:n:end] where n is the number of times you want to subsample). What do you see? Why is it important to have a good receiver sampling? A filter is simply a multiplicative factor applied in some transform domain, typically \\(f-h\\) or \\(f-k\\) , followed by an inverse transform. For example, a band-pass filter in the \\(f-h\\) domain filters out higher temporal frequencies by setting them to zero. A simple band-pass filter looks like this: F_hp = ones(length(f),length(h)) F_hp[(f.<5) .| (f.>20.),:] .= 0 imshow(F_hp, extent=[h[end], h[1], f[end], f[1]], aspect=20) colorbar() xlabel(\"offset [m]\");ylabel(\"frequency [Hz]\") PyObject Text(24.000000000000007, 0.5, 'frequency [Hz]') The filtered data looks like this imshow(fftrl(F_hp.*Data_fh, f, -1)[1], cmap=\"Greys\", vmin=-1, vmax=1, extent=[h[end], h[1], T[end], T[1]], aspect=1000) xlabel(\"offset [m]\");ylabel(\"frequency [Hz]\") PyObject Text(24.000000000000007, 0.5, 'frequency [Hz]') Do you see the artifacts? A way to reduce these artifacts is to smooth the filter. We can do this by convolving the filter with a triangular smoothing kernel. This is implemented in the function smooth_2D. The result looks like this: #using Pkg; Pkg.add(\"Images\") of you do not alread yhave it using Images function smooth_2D(input, n1, n2) t1 = [1:n1; n1-1:-1:1]/n1^2 t2 = [1:n2; n2-1:-1:1]/n2^2 kernel = t1 * t2' return imfilter(input, centered(kernel)) end smooth_2D (generic function with 1 method) F_hp_smooth = smooth_2D(F_hp, 5, 1) imshow(F_hp_smooth, extent=[h[end], h[1], f[end], f[1]], aspect=20) colorbar() xlabel(\"offset [m]\");ylabel(\"frequency [Hz]\") PyObject Text(24.000000000000007, 0.5, 'frequency [Hz]') imshow(fftrl(F_hp_smooth.*Data_fh, f, -1)[1], cmap=\"Greys\", vmin=-1, vmax=1, extent=[h[end], h[1], T[end], T[1]], aspect=1000) xlabel(\"offset [m]\");ylabel(\"frequency [Hz]\") PyObject Text(24.000000000000007, 0.5, 'frequency [Hz]') A (smoothed) filter in the \\(f-k\\) domain may look like this ff = [fi for fi in f, kxi in kx] kkx = [kxi for fi in f, kxi in kx] F_kx = zeros(length(fk),length(kx)) F_kx[(ff -1e3 * abs.(kkx) .> 5) .& (ff.<60)] .= 1 F_kx = smooth_2D(F_kx, 5, 5) imshow(F_kx, cmap=\"jet\", extent=[kx[end], kx[1], f[end], f[1]], aspect=.001) xlabel(\"wavenumber [1/m\");ylabel(\"frequency [Hz]\") PyObject Text(23.999999999999993, 0.5, 'frequency [Hz]') Questions Describe how you would design filters to clean up shot gathers shot_noise1 and shot_noise2. (hint: look the f-k transform and compare to the orinigal data) Try it and compare the result with the original shot gather. Radon transform The Radon tranform performs sums along lines with different intercepts \\(\\tau\\) ) and slopes \\(p\\) . Hence, it is sometimes refered to as the \\(\\tau-p\\) transform in geophysics. \\(\\hat{d}(\\tau,p) = \\int\\mathrm{d}h\\, d(t + ph, h)\\) The transform is implemented in the function lpradon. To get an idea of what this transform does, we consider the simple example in lines.segy. function lpradon(input, t, h, q, power, mode) # linear and parabolic Radon transform and its adjoint. # # Tristan van Leeuwen, 2012 # tleeuwen@eos.ubc.ca # # use: # out = lpradon(input,t,h,q,power,mode) # # input: # input - input matrix of size (length(t) x length(h)) for forward, (length(t) x length(q)) for adjoint) # t - time vector in seconds # h - offset vecror in meters # q - radon parameter # power - 1: linear radon, 2: parabolic radon # mode - 1: forward, -1: adjoint # # output: println(size(L)) # output matrix of size (length(t) x length(q)) for forward, (length(t) x length(h)) for adjoint) # # dt = t[2] - t[1] nt = length(t) nh = length(h) nq = length(q) nfft = 2*(Int64(nextpow(2,nt))) input_padded = zeros(nfft, size(input)[2]) input_padded[1:size(input)[1], :] = input[:, :] if mode == 1 input_padded = fft(input_padded, 1) out = zeros(Complex{Float64}, nfft, nq) for k = 2:Int(floor(nfft/2)) f = 2 .*pi*(k-1)/nfft/dt L = exp.(im*f*(h.^power)*q') tmp = conj((input_padded[k,:]' *L)[end:-1:1]) out[k,:] = tmp out[nfft + 2 - k, :] = conj(tmp) end out = real(ifft(out, 1)) out = out[1:nt, :] else input_padded = fft(input_padded,1) out = zeros(Complex{Float64}, nfft, nh) for k = 2:Int(floor(nfft/2)) f = 2 .*pi*(k-1)/nfft/dt L = exp.(im*f*(h.^power)*q') tmp = conj((input_padded[k,:]' *L')[end:-1:1]) out[k,:] = tmp out[nfft+2-k,:] = conj(tmp) end out = real(ifft(out,1)) out = out[1:nt, :] end return out end lpradon (generic function with 1 method) # Dowload and adapt path shot_radon = segy_read(\"/home/yzhang3198/Downloads/data_segy/lines.segy\") A = Float32.(shot_radon.data) h = get_header(shot_radon, \"SourceX\", scale=false) - get_header(shot, \"GroupX\", scale=false) dt = get_header(shot_radon, \"dt\")[1]/1e6 nt = get_header(shot_radon, \"ns\")[1] T = 0:dt:(nt -1)*dt \u250c Warning: Fixed length trace flag set in stream: IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=1705444, maxsize=Inf, ptr=3601, mark=-1) \u2514 @ SegyIO /home/yzhang3198/.julia/packages/SegyIO/ak2qG/src/read/read_file.jl:26 0.0:0.004:4.0 imshow(A, vmin=-.1, vmax=.1, cmap=\"Greys\", extent=[h[end], h[1], T[end], T[1]], aspect=1000) xlabel(\"offset [m]\");ylabel(\"time [s]\"); # which p-values p = 1e-3.*(-3:.05:3) # transform A_tp = lpradon(A, T, h, p, 1, 1); # plot imshow(A_tp, vmin=-.25, vmax=.25, cmap=\"Greys\", extent=[p[1], p[end], T[end], T[1]], aspect=.001) xlabel(\"slowness [s/m]\");ylabel(\"time [s]\"); Questions Can you interpret the results? Describe how you would design filters in the \\(\\tau-p\\) domain to separate the different events. Try it. Use the adjoint option of the transform to transform back to the physical domain.","title":"Exercise 4: Fourier and Radon filtering"},{"location":"Assignments/Exercise4/#exercise-4-fourier-and-radon-filtering","text":"In this exercise we will look at seismic data in different domains and investigate how we can exploit behaviour of different kinds of noise in these domains to design filters. Contents: - Data - Temporal Fourier transform - f-k filtering - Radon transform - Parabolic Radon transform using PyPlot, SegyIO, FFTW Data We use a single midpoint gather of the data used in the previous exercises: shot.segy (no big endian this time). # Dowload and adapt path shot = segy_read(\"/home/yzhang3198/Downloads/data_segy/shot.segy\") shot_data = Float32.(shot.data) h = get_header(shot, \"SourceX\", scale=false) - get_header(shot, \"GroupX\", scale=false) dt = get_header(shot, \"dt\")[1]/1e6 nt = get_header(shot, \"ns\")[1] T = 0:dt:(nt -1)*dt \u250c Warning: Fixed length trace flag set in stream: IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=1705444, maxsize=Inf, ptr=3601, mark=-1) \u2514 @ SegyIO /home/yzhang3198/.julia/packages/SegyIO/ak2qG/src/read/read_file.jl:26 0.0:0.004:4.0 imshow(shot_data, vmin=-1, vmax=1, cmap=\"Greys\", extent=[h[end], h[1], T[end], T[1]], aspect=1000) xlabel(\"offset [m]\");ylabel(\"time [s]\"); Temporal Fourier transform We can use fftrl to perform a Fourier transform along the temporal direction. The power spectrum (i.e., the absolute value of the transformed data) looks like function fftrl(a, t, mode) # fft for real-valued vectors # # Tristan van Leeuwen, 2012 # tleeuwen@eos.ubc.ca # # use: # [b,f] = fftrl(a,t,mode) # # input: # a - input data # t - time vector # mode: 1: forward, -1:inverse # # output: # b - vector nt = length(t) dt = t[2] - t[1] nf = Int(floor(nt/2)) + 1 tmax = t[end] - t[1] f = 0:1/tmax:.5/dt if mode == 1 b = fft(a,1) b = b[1:nf,:] elseif mode == -1 a = [a;conj(a[Int(ceil(nt/2)):-1:2,:])] b = ifft(a, 1) b = real(b) else error(\"Unknown mode\") end return b, f end fftrl (generic function with 1 method) Data_fh, f = fftrl(shot_data, T, 1) (Complex{Float32}[0.6844337f0 + 0.0f0im 0.9717815f0 + 0.0f0im \u2026 0.09694278f0 + 0.0f0im 0.004332781f0 + 0.0f0im; -0.70118594f0 - 0.4517814f0im -0.41232893f0 - 0.46060145f0im \u2026 -1.3077996f0 - 0.49731374f0im -1.4023542f0 - 0.48800778f0im; \u2026 ; -0.121281974f0 + 0.0007099677f0im -0.08637722f0 - 0.00040336605f0im \u2026 0.1578058f0 - 0.0011496469f0im 0.11014599f0 - 0.0002730284f0im; -0.12202144f0 + 0.00059955195f0im -0.08491863f0 - 0.00023266952f0im \u2026 0.15901898f0 - 0.0005980283f0im 0.10969794f0 - 0.00018512644f0im], 0.0:0.25:125.0) imshow(abs.(Data_fh), cmap=\"jet\", extent=[h[end], h[1], f[end], f[1]], aspect=20) xlabel(\"offset [m]\");ylabel(\"frequency [Hz]\") PyObject Text(24.000000000000007, 0.5, 'frequency [Hz]') f-k filtering A Fourier transform along both time and offset direction is often referred to as an transform. We can use fktran. The powerspectrum looks like function fktran(a,t,x,mode) \"\"\" f-k transform for real-values input. use: b, f, k = fktran(a,t,x,mode) input: a - matrix in t-x domain (nt x nx) t - time vector x - x vector mode - 1:forward, -1:inverse \"\"\" nt = length(t) nx = length(x) dt = t[2]-t[1] dx = x[2] - x[1] xmax = x[end] - x[1] tmax = t[end] - t[1] f = 0:1/tmax:.5/dt k = -.5/dx:1/xmax:.5/dx nf = length(f) if mode == 1 b = fft(a, 1) b = b[1:nf, :] b = ifft(b, 2) b = circshift(b,[0 ceil(Int, nx/2)-1]); elseif mode == -1 b = circshift(a,[0 floor(Int, nx/2)+1]); b = fft(b, 2) b = ifft([b;conj(b[end:-1:2,:])], 1) b = real(b) else error(\"unknown mode\") end return b, f, k end fktran (generic function with 1 method) Data_fk, fk, kx = fktran(shot_data, T, h, 1) (Complex{Float32}[0.002173217f0 + 0.37586603f0im -0.003716143f0 - 0.37589622f0im \u2026 -0.0037163715f0 + 0.37589744f0im 0.0021728363f0 - 0.37586543f0im; -0.06664165f0 + 0.37817085f0im 0.06513726f0 - 0.37864232f0im \u2026 -0.072564445f0 + 0.37711513f0im 0.07105575f0 - 0.37754175f0im; \u2026 ; 0.0033008547f0 + 0.40090138f0im -0.006969956f0 - 0.40087533f0im \u2026 -0.002999703f0 + 0.40091997f0im -0.0006929431f0 - 0.40090662f0im; 0.0019657868f0 + 0.40089262f0im -0.0056476546f0 - 0.4009117f0im \u2026 -0.0043306802f0 + 0.4009047f0im 0.000641849f0 - 0.4008996f0im], 0.0:0.25:125.0, 0.05:-0.00025:-0.05) imshow(abs.(Data_fk), cmap=\"jet\", extent=[kx[end], kx[1], f[end], f[1]], aspect=.001) xlabel(\"wavenumber [1/m\");ylabel(\"frequency [Hz]\") PyObject Text(23.999999999999993, 0.5, 'frequency [Hz]') back, _, _ = fktran(Data_fk, fk, kx, -1) imshow(back, vmin=-1, vmax=1, cmap=\"Greys\", extent=[h[end], h[1], T[end], T[1]], aspect=1000) xlabel(\"offset [m]\");ylabel(\"time [s]\"); size(shot_data) (1001, 401)","title":"Exercise 4: Fourier and Radon filtering"},{"location":"Assignments/Exercise4/#questions","text":"Subsample the data in the offset direction and look at the Fourier transform. (Hint: use Data[:,1:n:end] and h[1:n:end] where n is the number of times you want to subsample). What do you see? Why is it important to have a good receiver sampling? A filter is simply a multiplicative factor applied in some transform domain, typically \\(f-h\\) or \\(f-k\\) , followed by an inverse transform. For example, a band-pass filter in the \\(f-h\\) domain filters out higher temporal frequencies by setting them to zero. A simple band-pass filter looks like this: F_hp = ones(length(f),length(h)) F_hp[(f.<5) .| (f.>20.),:] .= 0 imshow(F_hp, extent=[h[end], h[1], f[end], f[1]], aspect=20) colorbar() xlabel(\"offset [m]\");ylabel(\"frequency [Hz]\") PyObject Text(24.000000000000007, 0.5, 'frequency [Hz]') The filtered data looks like this imshow(fftrl(F_hp.*Data_fh, f, -1)[1], cmap=\"Greys\", vmin=-1, vmax=1, extent=[h[end], h[1], T[end], T[1]], aspect=1000) xlabel(\"offset [m]\");ylabel(\"frequency [Hz]\") PyObject Text(24.000000000000007, 0.5, 'frequency [Hz]') Do you see the artifacts? A way to reduce these artifacts is to smooth the filter. We can do this by convolving the filter with a triangular smoothing kernel. This is implemented in the function smooth_2D. The result looks like this: #using Pkg; Pkg.add(\"Images\") of you do not alread yhave it using Images function smooth_2D(input, n1, n2) t1 = [1:n1; n1-1:-1:1]/n1^2 t2 = [1:n2; n2-1:-1:1]/n2^2 kernel = t1 * t2' return imfilter(input, centered(kernel)) end smooth_2D (generic function with 1 method) F_hp_smooth = smooth_2D(F_hp, 5, 1) imshow(F_hp_smooth, extent=[h[end], h[1], f[end], f[1]], aspect=20) colorbar() xlabel(\"offset [m]\");ylabel(\"frequency [Hz]\") PyObject Text(24.000000000000007, 0.5, 'frequency [Hz]') imshow(fftrl(F_hp_smooth.*Data_fh, f, -1)[1], cmap=\"Greys\", vmin=-1, vmax=1, extent=[h[end], h[1], T[end], T[1]], aspect=1000) xlabel(\"offset [m]\");ylabel(\"frequency [Hz]\") PyObject Text(24.000000000000007, 0.5, 'frequency [Hz]') A (smoothed) filter in the \\(f-k\\) domain may look like this ff = [fi for fi in f, kxi in kx] kkx = [kxi for fi in f, kxi in kx] F_kx = zeros(length(fk),length(kx)) F_kx[(ff -1e3 * abs.(kkx) .> 5) .& (ff.<60)] .= 1 F_kx = smooth_2D(F_kx, 5, 5) imshow(F_kx, cmap=\"jet\", extent=[kx[end], kx[1], f[end], f[1]], aspect=.001) xlabel(\"wavenumber [1/m\");ylabel(\"frequency [Hz]\") PyObject Text(23.999999999999993, 0.5, 'frequency [Hz]')","title":"Questions:"},{"location":"Assignments/Exercise4/#questions_1","text":"Describe how you would design filters to clean up shot gathers shot_noise1 and shot_noise2. (hint: look the f-k transform and compare to the orinigal data) Try it and compare the result with the original shot gather.","title":"Questions"},{"location":"Assignments/Exercise4/#radon-transform","text":"The Radon tranform performs sums along lines with different intercepts \\(\\tau\\) ) and slopes \\(p\\) . Hence, it is sometimes refered to as the \\(\\tau-p\\) transform in geophysics. \\(\\hat{d}(\\tau,p) = \\int\\mathrm{d}h\\, d(t + ph, h)\\) The transform is implemented in the function lpradon. To get an idea of what this transform does, we consider the simple example in lines.segy. function lpradon(input, t, h, q, power, mode) # linear and parabolic Radon transform and its adjoint. # # Tristan van Leeuwen, 2012 # tleeuwen@eos.ubc.ca # # use: # out = lpradon(input,t,h,q,power,mode) # # input: # input - input matrix of size (length(t) x length(h)) for forward, (length(t) x length(q)) for adjoint) # t - time vector in seconds # h - offset vecror in meters # q - radon parameter # power - 1: linear radon, 2: parabolic radon # mode - 1: forward, -1: adjoint # # output: println(size(L)) # output matrix of size (length(t) x length(q)) for forward, (length(t) x length(h)) for adjoint) # # dt = t[2] - t[1] nt = length(t) nh = length(h) nq = length(q) nfft = 2*(Int64(nextpow(2,nt))) input_padded = zeros(nfft, size(input)[2]) input_padded[1:size(input)[1], :] = input[:, :] if mode == 1 input_padded = fft(input_padded, 1) out = zeros(Complex{Float64}, nfft, nq) for k = 2:Int(floor(nfft/2)) f = 2 .*pi*(k-1)/nfft/dt L = exp.(im*f*(h.^power)*q') tmp = conj((input_padded[k,:]' *L)[end:-1:1]) out[k,:] = tmp out[nfft + 2 - k, :] = conj(tmp) end out = real(ifft(out, 1)) out = out[1:nt, :] else input_padded = fft(input_padded,1) out = zeros(Complex{Float64}, nfft, nh) for k = 2:Int(floor(nfft/2)) f = 2 .*pi*(k-1)/nfft/dt L = exp.(im*f*(h.^power)*q') tmp = conj((input_padded[k,:]' *L')[end:-1:1]) out[k,:] = tmp out[nfft+2-k,:] = conj(tmp) end out = real(ifft(out,1)) out = out[1:nt, :] end return out end lpradon (generic function with 1 method) # Dowload and adapt path shot_radon = segy_read(\"/home/yzhang3198/Downloads/data_segy/lines.segy\") A = Float32.(shot_radon.data) h = get_header(shot_radon, \"SourceX\", scale=false) - get_header(shot, \"GroupX\", scale=false) dt = get_header(shot_radon, \"dt\")[1]/1e6 nt = get_header(shot_radon, \"ns\")[1] T = 0:dt:(nt -1)*dt \u250c Warning: Fixed length trace flag set in stream: IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=1705444, maxsize=Inf, ptr=3601, mark=-1) \u2514 @ SegyIO /home/yzhang3198/.julia/packages/SegyIO/ak2qG/src/read/read_file.jl:26 0.0:0.004:4.0 imshow(A, vmin=-.1, vmax=.1, cmap=\"Greys\", extent=[h[end], h[1], T[end], T[1]], aspect=1000) xlabel(\"offset [m]\");ylabel(\"time [s]\"); # which p-values p = 1e-3.*(-3:.05:3) # transform A_tp = lpradon(A, T, h, p, 1, 1); # plot imshow(A_tp, vmin=-.25, vmax=.25, cmap=\"Greys\", extent=[p[1], p[end], T[end], T[1]], aspect=.001) xlabel(\"slowness [s/m]\");ylabel(\"time [s]\");","title":"Radon transform"},{"location":"Assignments/Exercise4/#questions_2","text":"Can you interpret the results? Describe how you would design filters in the \\(\\tau-p\\) domain to separate the different events. Try it. Use the adjoint option of the transform to transform back to the physical domain.","title":"Questions"},{"location":"Assignments/Exercise5/","text":"Assignment 4: From processing to inversion I Contents Linear systems JOLI Deconvolotion Linear systems A matrix is represented in Julia as follows A = [1 2;3 -1] 2\u00d72 Array{Int64,2}: 1 2 3 -1 The transpose of a matrix is obtained via A' A' 2\u00d72 LinearAlgebra.Adjoint{Int64,Array{Int64,2}}: 1 3 2 -1 In a similar manner, we can define a column vector as follows x = [2; 2] 2-element Array{Int64,1}: 2 2 Describe two ways to define a row vector. Now, consider the matrices A1 = [1/sqrt(2) 2/3 sqrt(2)/6;0 1/3 -2*sqrt(2)/3;-1/sqrt(2) 2/3 sqrt(2)/6]; A2 = [0 2 2;2 1 -3;1 0 -2]; A3 = [3 1;1 0;2 1]; A4 = [2 4 3; 1 3 1]; Tasks Look at A1'*A1, what kind of matrix is A1? What does this mean? Look at A2 [1;2;3] and A2 [3;1;4], what can you say about the matrix A2? What do you call a linear system defined by matrix A3? What do you call a linear system defined by matrix A4? If a matrix is invertible, we can explicitly find the inverse with inv find a solution of A1*x = [6;-3;0], is there only one solution? Do you really need inv here? find a solution of A2*x = [4;0;-1], is there only one solution? What characterizes the solution you found? find a solution of A3*x = [5;2;5], is there only one solution? What characterizes the solution you found? find a solution of A4*x = [10;5], is there only one solution? What characterizes the solution you found? JOLI https://github.com/slimgroup/JOLI.jl The JOLI toolbox gives a way to represent matrices implicitly. A nice example is the Fourier transform. In julia, the Fourier transform of a vector is given by fft(x). We can explicitly construct a matrix representing the Fourier transform as follows using FFTW # dimension N = 10 F1 = zeros(Complex{Float64}, N,N) for k = 1:N # construct k-th unit vector ek = zeros(N,1) ek[k] = 1 # make column of matrix F1[:, k]= fft(ek) end Look at the matrix, what do you notice? Verify that it gives the same result as fft by trying on a vector We can also define the FFT using JOLI: using JOLI F2 = joDFT(N) varinfo(r\"F1\"), varinfo(r\"F2\") (| name | size | summary | |:---- | ---------:|:------------------------------- | | F1 | 1.602 KiB | 10\u00d710 Array{Complex{Float64},2} | , | name | size | summary | |:---- | ---------:|:------------------------------------------ | | F2 | 566 bytes | joLinearFunction{Float64,Complex{Float64}} | ) And this is only a small example! The reason why we want to have such operations behave like matrices is that we can use (some) standard algorithms that where written to work with matrices to work with large scale operations. As an example we use a Gaussian matrix: N = 10000; # NxN Gaussian matrix G1 = ones(N, N); # NxN Gaussian JOLI operator (will represent a different matrix than G1 becuase it is gerenated randomly) G2 = joOnes(N); varinfo(r\"G1\"),varinfo(r\"G2\") (| name | size | summary | |:---- | -----------:|:---------------------------- | | G1 | 762.939 MiB | 10000\u00d710000 Array{Float64,2} | , | name | size | summary | |:---- | ---------:|:------------------------- | | G2 | 246 bytes | joMatrix{Float64,Float64} | ) Deconvolution We some signal \\(f(t)\\) which is a convolution of some unkown signal \\(g(t)\\) and a known filter \\(w(t)\\) . Given \\(f\\) and \\(w\\) we would like to retreive \\(g\\) . For the example we use: # time axis t = 0:.001:2'; N = length(t); # true signal g has approx k spikes with random amplitudes k = 20; g = zeros(N,1); g[rand(1:N, k)] = randn(k,1); # filter w = (1 .-2*1e3*(t .-.2).^2).*exp.(-1e3*(t .-.2).^2); # plot using PyPlot figure(); plot(t,g); xlabel(\"t [s]\");ylabel(\"g(t)\"); figure(); plot(t,w); xlabel(\"t [s]\");ylabel(\"w(t)\"); \u250c Info: Recompiling stale cache file /home/yzhang3198/.julia/compiled/v1.2/PyPlot/oatAj.ji for PyPlot [d330b81b-6aea-500a-939a-2ce795aea3ee] \u2514 @ Base loading.jl:1240 First, we consider the forward problem of convolving a signal, using JOLI. Task: Perform the convolution using the usual julia commands fft, ifft and element-wise multiplication. Name your result f1. Hint: what is convolution in frequency domain?*. We can also create a JOLI operator to do the same. We can construct an operator to do the multiplication with the filter using joDiag. # JOLI operator to perform convolution. C = joDFT(N)'*joDiag(wf)*joDFT(N); f2 = C*g; figure(); plot(t,f1) plot(t,f2) plot(t,g); xlabel(\"t [s]\");ylabel(\"f(t)\");legend([\"normal\",\"JOLI\", \"g\"]); Task Compare the results of both. Compare f to g, what do you notice? Assuming that your convolution operator is called C: Do you think C has a null-space? If so, describe it. (Hint: look at the filter). Now, construct the signal f using your JOLI operator and add some noise. f = C*g + 1e-3*randn(N); Task Use the adjoint of C as an approximation to the inverse, i.e. approximate the adjoint of C to the observation f. what does this correspond to and what does the reconstruction look like? Task Follow the script below, use lsqr to invert for g. (you might need to increase the number of iterations.) Look at the signal that is predicted by your reconstruction, do you see a difference with the true signal? #import Pkg; #Pkg.add(\"IterativeSolvers\") # true signal using IterativeSolvers gt = lsqr(C, f, damp=1e0) lsqr will give us a solution that has a small two-norm and explains the data. Alternatively, we can use another solver that will give us a spiky solution and explains the data. This solver is spgl1. Try inversion via spgl1. https://github.com/slimgroup/GenSPGL.jl using GenSPGL # Pkg.add(url=\"https://github.com/slimgroup/GenSPGL.jl\") using LinearAlgebra # Solve opts = spgOptions(optTol = 1e-10, verbosity = 1) #gtt, r, grads, info = spgl1(C, vec(f), tau = 0., sigma = norm(f - C*gt)); Task Is this solution closer to the true one? Look at the predicted signal for this solution, do you see a difference with the true signal? Can we really say that this is a better solution? 2D compressive sensing In the following experiment, we extend the 1D compressive sensing to 2D---i.e., we aim to recover a sparse image (rather than a vector). Let's first set up the ground truth vector \\(g\\) . n = (64, 64); nn = prod(n); k = 200; g = zeros(n); idx1 = rand(1:n[1], k); idx2 = rand(1:n[1], k); for i = 1:k g[idx1[i],idx2[i]] = randn(); end Task: plot \\(g\\) by imshow function with colorbars. Is \\(g\\) sparse? How many non-zero entries are in \\(g\\) ? Then, let's make a forward operator \\(A\\) by JOLI. Following what we did in 1D, we hit the ground truth vector by the matrix \\(A\\) and add some noise to get the observation \\(y\\) . Notice that the operator \\(A\\) works on vectorized image. subsamp = 0.25f0 # 25% subsampling ratio A = joRestriction(nn, sort(randperm(nn)[1:Int(round(subsamp*nn))]))*joRomberg(n[1],n[2]) y = A * vec(g) + 1f-3*randn(size(A,1)); Task: do LSQR and SPGL1. Plot the results. Compare with each other. What do you see? Task: compute the norm of the residuals from the results by LSQR and SPGL1. Which one is larger? Any conclusion from these experiments?","title":"Assignment 4: From processing to inversion I"},{"location":"Assignments/Exercise5/#assignment-4-from-processing-to-inversion-i","text":"","title":"Assignment 4: From processing to inversion I"},{"location":"Assignments/Exercise5/#contents","text":"Linear systems JOLI Deconvolotion","title":"Contents"},{"location":"Assignments/Exercise5/#linear-systems","text":"A matrix is represented in Julia as follows A = [1 2;3 -1] 2\u00d72 Array{Int64,2}: 1 2 3 -1 The transpose of a matrix is obtained via A' A' 2\u00d72 LinearAlgebra.Adjoint{Int64,Array{Int64,2}}: 1 3 2 -1 In a similar manner, we can define a column vector as follows x = [2; 2] 2-element Array{Int64,1}: 2 2 Describe two ways to define a row vector. Now, consider the matrices A1 = [1/sqrt(2) 2/3 sqrt(2)/6;0 1/3 -2*sqrt(2)/3;-1/sqrt(2) 2/3 sqrt(2)/6]; A2 = [0 2 2;2 1 -3;1 0 -2]; A3 = [3 1;1 0;2 1]; A4 = [2 4 3; 1 3 1];","title":"Linear systems"},{"location":"Assignments/Exercise5/#tasks","text":"Look at A1'*A1, what kind of matrix is A1? What does this mean? Look at A2 [1;2;3] and A2 [3;1;4], what can you say about the matrix A2? What do you call a linear system defined by matrix A3? What do you call a linear system defined by matrix A4? If a matrix is invertible, we can explicitly find the inverse with inv find a solution of A1*x = [6;-3;0], is there only one solution? Do you really need inv here? find a solution of A2*x = [4;0;-1], is there only one solution? What characterizes the solution you found? find a solution of A3*x = [5;2;5], is there only one solution? What characterizes the solution you found? find a solution of A4*x = [10;5], is there only one solution? What characterizes the solution you found?","title":"Tasks"},{"location":"Assignments/Exercise5/#joli","text":"https://github.com/slimgroup/JOLI.jl The JOLI toolbox gives a way to represent matrices implicitly. A nice example is the Fourier transform. In julia, the Fourier transform of a vector is given by fft(x). We can explicitly construct a matrix representing the Fourier transform as follows using FFTW # dimension N = 10 F1 = zeros(Complex{Float64}, N,N) for k = 1:N # construct k-th unit vector ek = zeros(N,1) ek[k] = 1 # make column of matrix F1[:, k]= fft(ek) end Look at the matrix, what do you notice? Verify that it gives the same result as fft by trying on a vector We can also define the FFT using JOLI: using JOLI F2 = joDFT(N) varinfo(r\"F1\"), varinfo(r\"F2\") (| name | size | summary | |:---- | ---------:|:------------------------------- | | F1 | 1.602 KiB | 10\u00d710 Array{Complex{Float64},2} | , | name | size | summary | |:---- | ---------:|:------------------------------------------ | | F2 | 566 bytes | joLinearFunction{Float64,Complex{Float64}} | ) And this is only a small example! The reason why we want to have such operations behave like matrices is that we can use (some) standard algorithms that where written to work with matrices to work with large scale operations. As an example we use a Gaussian matrix: N = 10000; # NxN Gaussian matrix G1 = ones(N, N); # NxN Gaussian JOLI operator (will represent a different matrix than G1 becuase it is gerenated randomly) G2 = joOnes(N); varinfo(r\"G1\"),varinfo(r\"G2\") (| name | size | summary | |:---- | -----------:|:---------------------------- | | G1 | 762.939 MiB | 10000\u00d710000 Array{Float64,2} | , | name | size | summary | |:---- | ---------:|:------------------------- | | G2 | 246 bytes | joMatrix{Float64,Float64} | )","title":"JOLI"},{"location":"Assignments/Exercise5/#deconvolution","text":"We some signal \\(f(t)\\) which is a convolution of some unkown signal \\(g(t)\\) and a known filter \\(w(t)\\) . Given \\(f\\) and \\(w\\) we would like to retreive \\(g\\) . For the example we use: # time axis t = 0:.001:2'; N = length(t); # true signal g has approx k spikes with random amplitudes k = 20; g = zeros(N,1); g[rand(1:N, k)] = randn(k,1); # filter w = (1 .-2*1e3*(t .-.2).^2).*exp.(-1e3*(t .-.2).^2); # plot using PyPlot figure(); plot(t,g); xlabel(\"t [s]\");ylabel(\"g(t)\"); figure(); plot(t,w); xlabel(\"t [s]\");ylabel(\"w(t)\"); \u250c Info: Recompiling stale cache file /home/yzhang3198/.julia/compiled/v1.2/PyPlot/oatAj.ji for PyPlot [d330b81b-6aea-500a-939a-2ce795aea3ee] \u2514 @ Base loading.jl:1240 First, we consider the forward problem of convolving a signal, using JOLI.","title":"Deconvolution"},{"location":"Assignments/Exercise5/#task-perform-the-convolution-using-the-usual-julia-commands-fft-ifft-and-element-wise-multiplication-name-your-result-f1-hint-what-is-convolution-in-frequency-domain","text":"We can also create a JOLI operator to do the same. We can construct an operator to do the multiplication with the filter using joDiag. # JOLI operator to perform convolution. C = joDFT(N)'*joDiag(wf)*joDFT(N); f2 = C*g; figure(); plot(t,f1) plot(t,f2) plot(t,g); xlabel(\"t [s]\");ylabel(\"f(t)\");legend([\"normal\",\"JOLI\", \"g\"]);","title":"Task: Perform the convolution using the usual julia commands fft, ifft and element-wise multiplication. Name your result f1. Hint: what is convolution in frequency domain?*."},{"location":"Assignments/Exercise5/#task","text":"Compare the results of both. Compare f to g, what do you notice? Assuming that your convolution operator is called C: Do you think C has a null-space? If so, describe it. (Hint: look at the filter). Now, construct the signal f using your JOLI operator and add some noise. f = C*g + 1e-3*randn(N);","title":"Task"},{"location":"Assignments/Exercise5/#task_1","text":"Use the adjoint of C as an approximation to the inverse, i.e. approximate the adjoint of C to the observation f. what does this correspond to and what does the reconstruction look like?","title":"Task"},{"location":"Assignments/Exercise5/#task_2","text":"Follow the script below, use lsqr to invert for g. (you might need to increase the number of iterations.) Look at the signal that is predicted by your reconstruction, do you see a difference with the true signal? #import Pkg; #Pkg.add(\"IterativeSolvers\") # true signal using IterativeSolvers gt = lsqr(C, f, damp=1e0) lsqr will give us a solution that has a small two-norm and explains the data. Alternatively, we can use another solver that will give us a spiky solution and explains the data. This solver is spgl1. Try inversion via spgl1. https://github.com/slimgroup/GenSPGL.jl using GenSPGL # Pkg.add(url=\"https://github.com/slimgroup/GenSPGL.jl\") using LinearAlgebra # Solve opts = spgOptions(optTol = 1e-10, verbosity = 1) #gtt, r, grads, info = spgl1(C, vec(f), tau = 0., sigma = norm(f - C*gt));","title":"Task"},{"location":"Assignments/Exercise5/#task_3","text":"Is this solution closer to the true one? Look at the predicted signal for this solution, do you see a difference with the true signal? Can we really say that this is a better solution?","title":"Task"},{"location":"Assignments/Exercise5/#2d-compressive-sensing","text":"In the following experiment, we extend the 1D compressive sensing to 2D---i.e., we aim to recover a sparse image (rather than a vector). Let's first set up the ground truth vector \\(g\\) . n = (64, 64); nn = prod(n); k = 200; g = zeros(n); idx1 = rand(1:n[1], k); idx2 = rand(1:n[1], k); for i = 1:k g[idx1[i],idx2[i]] = randn(); end","title":"2D compressive sensing"},{"location":"Assignments/Exercise5/#task-plot-g-by-imshow-function-with-colorbars-is-g-sparse-how-many-non-zero-entries-are-in-g","text":"Then, let's make a forward operator \\(A\\) by JOLI. Following what we did in 1D, we hit the ground truth vector by the matrix \\(A\\) and add some noise to get the observation \\(y\\) . Notice that the operator \\(A\\) works on vectorized image. subsamp = 0.25f0 # 25% subsampling ratio A = joRestriction(nn, sort(randperm(nn)[1:Int(round(subsamp*nn))]))*joRomberg(n[1],n[2]) y = A * vec(g) + 1f-3*randn(size(A,1));","title":"Task: plot \\(g\\) by imshow function with colorbars. Is \\(g\\) sparse? How many non-zero entries are in \\(g\\)?"},{"location":"Assignments/Exercise5/#task-do-lsqr-and-spgl1-plot-the-results-compare-with-each-other-what-do-you-see","text":"","title":"Task: do LSQR and SPGL1. Plot the results. Compare with each other. What do you see?"},{"location":"Assignments/Exercise5/#task-compute-the-norm-of-the-residuals-from-the-results-by-lsqr-and-spgl1-which-one-is-larger-any-conclusion-from-these-experiments","text":"","title":"Task: compute the norm of the residuals from the results by LSQR and SPGL1. Which one is larger? Any conclusion from these experiments?"},{"location":"Assignments/Exercise6/","text":"Exercise 6: From processing to inversion II Contents: Kronecker NMO-Stack-deconvolution Inverting the Radon transform Kronecker Given a matrix X, we often want to apply operations along both dimensions. For example, if each column is a trace we can do a temporal fourier transform of each trace as follows using JOLI, GenSPGL, PyPlot, FFTW, LinearAlgebra # dummy matrix n1 = 10 n2 = 5 X = joComplex.(randn(n1,n2)) # fft along first dimension F1 = joDFT(n1; DDT=joComplex) Y = F1*X 10\u00d75 Array{Complex{Float64},2}: 1.41557+0.0im -1.60638+0.0im \u2026 0.430018+0.0im 0.672767+0.450352im -0.938118+0.759956im -0.1883-0.991497im 0.406392+0.205739im -0.302384+0.247512im 0.631065-1.30804im -0.618123-0.848047im -0.121208+0.443261im -0.646604-1.17498im -0.787335-0.450483im 0.0533324-0.395285im -0.760621+0.0204424im 0.294818+0.0im -0.429069+0.0im \u2026 -0.250248+0.0im -0.787335+0.450483im 0.0533324+0.395285im -0.760621-0.0204424im -0.618123+0.848047im -0.121208-0.443261im -0.646604+1.17498im 0.406392-0.205739im -0.302384-0.247512im 0.631065+1.30804im 0.672767-0.450352im -0.938118-0.759956im -0.1883+0.991497im We can do an fft along the second dimension as follows F2 = joDFT(n2; DDT=joComplex) Y = transpose(F2*copy(transpose(X))); Finally, we can combine both in one step as follows Y = transpose(F2*copy(transpose(F1*X))); We can do the equivalent operation on the vectorized version of X via the Kronecker product. The formula is : $ \\mathrm{vec}(AXB) = (B^T\\otimes A)\\mathrm{vec}(X) $. where \\(\\mathrm{vec}\\) vectorizes a matrix \\(X(:)\\) . Use joKron to construct a 2D fft operator that works on a vectorized version of X, X(:). Show that the result is the same as when using the operators F1 and F2 separately. # 2D FFT operator F12 = joKron(F2,F1); # compare: F12*X(:) should be the same as Y(:) norm(F12*X[:] - Y[:]) 0.0 NMO-Stack-deconvolution We revisit the NMO and stack operations we saw a few weeks before, but we will use it backwards . Remember the conventional flow was Data -> NMO corrected data -> stack -> image We will now traverse this chain in the reverse order, each time using the adjoint of the operations. The reflectivity (image) can be represented by a convolution of a spike train with a wavelet, as we saw last week. We will build this chain of operations reflectivity -> convolved reflectivity -> NMO corrected data -> data, step-by-step. First, define a time and offset axis. # time and offset grid t = Float64.(0:.004:1); nt = length(t); h = Float64.(0.0:10.0:1000.0); nh = length(h); We make a reflectivity series with 3 spikes and define a wavelet. # reflectivity r = zeros(nt,1); r[51] = 1 r[101] = -.5 r[151] = .75 # wavelet w = (1 .-2*1e3*(t .-.1).^2).*exp.(-1e3 .*(t .-.1).^2) 251-element Array{Float64,1}: -0.0008625986654872107 -0.0017333620023927386 -0.003359640068423334 -0.00627815407118934 -0.011305429764281264 -0.019606375823452423 -0.032722754572662376 -0.05251269265727092 -0.08094144772594736 -0.11966839901351634 -0.16940707917321376 -0.22910148611303477 -0.29505929933463465 \u22ee -8.75952886e-316 -9.2021e-319 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 The convolution is done by using the FFT SPOT operators, just like in the last exercise. # convolution operator C = joDFT(nt)'*joDiag(fft(w))*joDFT(nt); Next, we need to extend the the reflectivity to be a function of time and offset. We are trying to undo the stack operation to create NMO corrected data. Let's first look at the stack. Given a matrix, we can stack the columns by multiplying with a vector of all ones: # test matrix X =[1 2; 3 4; 5 6] Y = X*[1;1] 3-element Array{Int64,1}: 3 7 11 Construct a JOLI operator that stacks a vectorized input matrix of size nt x nh along the columns. Use joDirac to define an identity operator. Apply the operators C and S to the vector r to get something that resembles NMO-corrected data. You can reshape the vector into a matrix by using reshape. Plot the result. The next step is to construct an NMO operator. Please follow the function nmo in Exercise2 and define a JOLI operator for a constant velocity of 2000 m/s. Don't forget to take care of the shape of input and output (they should both be vectors in proper lengths). You can do this by simply filling the blanks below. Apply it to the result of the previous exercise and plot the result. function nmo(cmp, t, off, v,flag) # NMO correction and adjoint # # use: # out = nmo(in,t,h,v,flag) # # input: # in - data matrix of size [length(t) x length(h)], each column is a trace # t - time vector [s] # offsets - offset vector [m] # v - NMO velocity [m/s] as vector of size [length(t) x 1]. # flag - 1:forward, -1:adjoint # # output # out - data matrix of size [length(t) x length(h)], each column is a trace if size(cmp, 2) == 1 return cmp end # size of data nt, nh = size(cmp) # make sure t and v are column vectors t = t[:] v = v[:] # initialize output out = zeros(nt, nh) # loop over offset for i = 1:nh # NMO traveltime tau = sqrt.(t.^2 + off[i].^2 ./v.^2); A = getLA(t,tau); # interpolate, forward or adjoint new = zeros(size(out[:,i])) if flag == 1 new[1:size(A*cmp[:,i])[1]] = A*cmp[:,i] else new[1:size(A'*cmp[:,i])[1]] = A'*cmp[:,i] end out[:,i] = new[1:nt] #cmp end return vec(out) end function nmo_forward(vec_cmp,t,h,vel) mat_cmp = _ # to be done return nmo(mat_cmp,t,h,vel,1) end function nmo_adjoint(vec_cmp,t,h,vel) mat_cmp = _ # to be done return nmo(mat_cmp,t,h,vel,-1) end function joNMO(t,h,vel, n) C = joLinearFunctionFwd_T(n, n, v -> nmo_forward(v, t,h,vel), w -> nmo_adjoint(w, t,h,vel), Float64, Float64,name=\"NMO operator\") end B = joNMO(_, _, _, _) Now, define a combined operator that predicts data given a spike train. Check that your combined operator satisfies the dottest Make data for the spike train r and add some noise. Invert the operator with both lsqr and spgl1 (see previous exercise). Inverting the Radon transform In the previous exercise we saw that the Radon transform is not unitary. This means that its adjoint is not its inverse. Here, we will set up a JOLI operator for the Radon transform and invert it using lsqr and spgl1. If the computation takes too long you can use a coarser sampling of the q axis. read the data parab.segy Set up a parabolic radon transform JOLI operator , R=joRadon(....; DDT=joFloat) Plot the data in the Radon domain, and go back to the orininal data using the adjoint. Compare to the original data. - - What do you notice? You want to obtain data in the Radon domain b for which the predicted data in the t,h domain is close to the original data. How would you do this?. Setup a damped least-squares system and invert with lsqr. Try different damping parameters and explain what you see. Hint: us lsqr(..., damp=) for a damped least square. Use the original system and invert with spgl1(A,b,0,tolerance). Describe a possible application of this technique in seismic processing Do not forget to turn your data into Float64","title":"Exercise 6: From processing to inversion II"},{"location":"Assignments/Exercise6/#exercise-6-from-processing-to-inversion-ii","text":"Contents: Kronecker NMO-Stack-deconvolution Inverting the Radon transform","title":"Exercise 6: From processing to inversion II"},{"location":"Assignments/Exercise6/#kronecker","text":"Given a matrix X, we often want to apply operations along both dimensions. For example, if each column is a trace we can do a temporal fourier transform of each trace as follows using JOLI, GenSPGL, PyPlot, FFTW, LinearAlgebra # dummy matrix n1 = 10 n2 = 5 X = joComplex.(randn(n1,n2)) # fft along first dimension F1 = joDFT(n1; DDT=joComplex) Y = F1*X 10\u00d75 Array{Complex{Float64},2}: 1.41557+0.0im -1.60638+0.0im \u2026 0.430018+0.0im 0.672767+0.450352im -0.938118+0.759956im -0.1883-0.991497im 0.406392+0.205739im -0.302384+0.247512im 0.631065-1.30804im -0.618123-0.848047im -0.121208+0.443261im -0.646604-1.17498im -0.787335-0.450483im 0.0533324-0.395285im -0.760621+0.0204424im 0.294818+0.0im -0.429069+0.0im \u2026 -0.250248+0.0im -0.787335+0.450483im 0.0533324+0.395285im -0.760621-0.0204424im -0.618123+0.848047im -0.121208-0.443261im -0.646604+1.17498im 0.406392-0.205739im -0.302384-0.247512im 0.631065+1.30804im 0.672767-0.450352im -0.938118-0.759956im -0.1883+0.991497im We can do an fft along the second dimension as follows F2 = joDFT(n2; DDT=joComplex) Y = transpose(F2*copy(transpose(X))); Finally, we can combine both in one step as follows Y = transpose(F2*copy(transpose(F1*X))); We can do the equivalent operation on the vectorized version of X via the Kronecker product. The formula is : $ \\mathrm{vec}(AXB) = (B^T\\otimes A)\\mathrm{vec}(X) $. where \\(\\mathrm{vec}\\) vectorizes a matrix \\(X(:)\\) . Use joKron to construct a 2D fft operator that works on a vectorized version of X, X(:). Show that the result is the same as when using the operators F1 and F2 separately. # 2D FFT operator F12 = joKron(F2,F1); # compare: F12*X(:) should be the same as Y(:) norm(F12*X[:] - Y[:]) 0.0","title":"Kronecker"},{"location":"Assignments/Exercise6/#nmo-stack-deconvolution","text":"We revisit the NMO and stack operations we saw a few weeks before, but we will use it backwards . Remember the conventional flow was Data -> NMO corrected data -> stack -> image We will now traverse this chain in the reverse order, each time using the adjoint of the operations. The reflectivity (image) can be represented by a convolution of a spike train with a wavelet, as we saw last week. We will build this chain of operations reflectivity -> convolved reflectivity -> NMO corrected data -> data, step-by-step. First, define a time and offset axis. # time and offset grid t = Float64.(0:.004:1); nt = length(t); h = Float64.(0.0:10.0:1000.0); nh = length(h); We make a reflectivity series with 3 spikes and define a wavelet. # reflectivity r = zeros(nt,1); r[51] = 1 r[101] = -.5 r[151] = .75 # wavelet w = (1 .-2*1e3*(t .-.1).^2).*exp.(-1e3 .*(t .-.1).^2) 251-element Array{Float64,1}: -0.0008625986654872107 -0.0017333620023927386 -0.003359640068423334 -0.00627815407118934 -0.011305429764281264 -0.019606375823452423 -0.032722754572662376 -0.05251269265727092 -0.08094144772594736 -0.11966839901351634 -0.16940707917321376 -0.22910148611303477 -0.29505929933463465 \u22ee -8.75952886e-316 -9.2021e-319 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 The convolution is done by using the FFT SPOT operators, just like in the last exercise. # convolution operator C = joDFT(nt)'*joDiag(fft(w))*joDFT(nt); Next, we need to extend the the reflectivity to be a function of time and offset. We are trying to undo the stack operation to create NMO corrected data. Let's first look at the stack. Given a matrix, we can stack the columns by multiplying with a vector of all ones: # test matrix X =[1 2; 3 4; 5 6] Y = X*[1;1] 3-element Array{Int64,1}: 3 7 11 Construct a JOLI operator that stacks a vectorized input matrix of size nt x nh along the columns. Use joDirac to define an identity operator. Apply the operators C and S to the vector r to get something that resembles NMO-corrected data. You can reshape the vector into a matrix by using reshape. Plot the result. The next step is to construct an NMO operator. Please follow the function nmo in Exercise2 and define a JOLI operator for a constant velocity of 2000 m/s. Don't forget to take care of the shape of input and output (they should both be vectors in proper lengths). You can do this by simply filling the blanks below. Apply it to the result of the previous exercise and plot the result. function nmo(cmp, t, off, v,flag) # NMO correction and adjoint # # use: # out = nmo(in,t,h,v,flag) # # input: # in - data matrix of size [length(t) x length(h)], each column is a trace # t - time vector [s] # offsets - offset vector [m] # v - NMO velocity [m/s] as vector of size [length(t) x 1]. # flag - 1:forward, -1:adjoint # # output # out - data matrix of size [length(t) x length(h)], each column is a trace if size(cmp, 2) == 1 return cmp end # size of data nt, nh = size(cmp) # make sure t and v are column vectors t = t[:] v = v[:] # initialize output out = zeros(nt, nh) # loop over offset for i = 1:nh # NMO traveltime tau = sqrt.(t.^2 + off[i].^2 ./v.^2); A = getLA(t,tau); # interpolate, forward or adjoint new = zeros(size(out[:,i])) if flag == 1 new[1:size(A*cmp[:,i])[1]] = A*cmp[:,i] else new[1:size(A'*cmp[:,i])[1]] = A'*cmp[:,i] end out[:,i] = new[1:nt] #cmp end return vec(out) end function nmo_forward(vec_cmp,t,h,vel) mat_cmp = _ # to be done return nmo(mat_cmp,t,h,vel,1) end function nmo_adjoint(vec_cmp,t,h,vel) mat_cmp = _ # to be done return nmo(mat_cmp,t,h,vel,-1) end function joNMO(t,h,vel, n) C = joLinearFunctionFwd_T(n, n, v -> nmo_forward(v, t,h,vel), w -> nmo_adjoint(w, t,h,vel), Float64, Float64,name=\"NMO operator\") end B = joNMO(_, _, _, _) Now, define a combined operator that predicts data given a spike train. Check that your combined operator satisfies the dottest Make data for the spike train r and add some noise. Invert the operator with both lsqr and spgl1 (see previous exercise).","title":"NMO-Stack-deconvolution"},{"location":"Assignments/Exercise6/#inverting-the-radon-transform","text":"In the previous exercise we saw that the Radon transform is not unitary. This means that its adjoint is not its inverse. Here, we will set up a JOLI operator for the Radon transform and invert it using lsqr and spgl1. If the computation takes too long you can use a coarser sampling of the q axis. read the data parab.segy Set up a parabolic radon transform JOLI operator , R=joRadon(....; DDT=joFloat) Plot the data in the Radon domain, and go back to the orininal data using the adjoint. Compare to the original data. - - What do you notice? You want to obtain data in the Radon domain b for which the predicted data in the t,h domain is close to the original data. How would you do this?. Setup a damped least-squares system and invert with lsqr. Try different damping parameters and explain what you see. Hint: us lsqr(..., damp=) for a damped least square. Use the original system and invert with spgl1(A,b,0,tolerance). Describe a possible application of this technique in seismic processing Do not forget to turn your data into Float64","title":"Inverting the Radon transform"},{"location":"Assignments/Exercise7/","text":"Homework 4 : Seismic imaging In this exercise, we conduct a small 2D seismic imaging experiment on a 4-layer model example with JUDI . We suggest you use a Docker image to run the experiment so that software packages are properly installed. To use the docker image, first install docker. Then, in the terminal, do docker run -p 8888:8888 ziyiyin97/ccs-env:v4.4 Running this command will produce an output that looks like Copy/paste this URL into your browser when you connect for the first time, to login with a token: http://af637030c092:8888/?token=8f6c664eb945f9c6b7cd72669fef04a6dc70c08194cb87e9 or http://127.0.0.1:8888/?token=8f6c664eb945f9c6b7cd72669fef04a6dc70c08194cb87e9 Copy paste the URL in your browser and replace (af637030c092 or 127.0.0.1) by localhost . You will then be directed to a jupyter folder that contains the notebooks for the projects. Then, we can create a new julia script and run the experiment in it. A couple of things before we go into the details: 1. Try to give your interpretation to every figure you plot. What is each event in the figure? 2. Plotting is hard. When you make plots, make sure you use the correct labels and units so that images are in meters, data is in seconds. Also make sure you clip the image by vmin and vmax keywords in imshow function so that you see all the events in the image. 3. To plot seismic data and images (e.g. RTM), we always put vmin = -vmax so that \\(0\\) is at the center in your colorscale. Generally, we use cmap=\"seismic\" to plot seismic data, cmap=\"Greys\" to plot seismic images. Let's start! First we load the packages as usual. ## First do using Pkg; Pkg.add(xxx) in case any package is not installed yet using JUDI, PyPlot, Images, JOLI, IterativeSolvers, LinearAlgebra, Printf, Statistics Here, we set up a \\(4\\) -layer model. The velocities in each layer are \\(1.5/2.5/3/3.5\\) km/s. We often call the first layer as the water layer/column in marine acquisition and assume to know its depth. # number of gridpoints n = (201, 101) # Grid spacing d = (10f0, 10f0) # in [m] # Origin o = (0f0, 0f0) # in [m] # Extent extent = (o[1], o[1]+(n[1]-1)*d[1], o[2]+(n[2]-1)*d[2], o[2]) # in [m] # Velocity [km/s] v = ones(Float32,n) .+ 0.5f0 v[:,20:50] .= 2.5f0 v[:,51:71] .= 3f0 v[:,71:end] .= 3.5f0 Wave-equation simulations in JUDI are parameterized by squared slowness \\(\\mathbf{m}\\) . For migration, we make up a background model \\(\\mathbf{m}_0\\) as a smoothed version of the ground truth one. To make things simple, we assume to use the exact water layer in the background model. The squared slowness perturbation \\(\\delta\\mathbf{m}\\) , as the difference of \\(\\mathbf{m}\\) and \\(\\mathbf{m}_0\\) , only contains the sharp reflectors. # Slowness squared [s^2/km^2] m = (1f0 ./ v).^2 m0 = deepcopy(m) m0[:,20:end] = convert(Array{Float32,2},imfilter(m[:,20:end], Kernel.gaussian(5))) # smooth the true velocity to get m0 dm = vec(m - m0) figure(figsize=(20,12)); subplot(1,3,1) imshow(reshape(m,n)', extent=extent, interpolation=\"none\", cmap=\"jet\");title(\"m\") xlabel(\"X [m]\"); ylabel(\"Z [m]\"); subplot(1,3,2) imshow(reshape(m0,n)', extent=extent, interpolation=\"none\", cmap=\"jet\");title(\"m0\") xlabel(\"X [m]\"); ylabel(\"Z [m]\"); subplot(1,3,3) imshow(reshape(dm,n)', extent=extent, interpolation=\"none\",cmap=\"Greys\");title(\"dm\") xlabel(\"X [m]\"); ylabel(\"Z [m]\"); The goal of seismic imaging/migration is to acquire this \\(\\delta\\mathbf{m}\\) from seismic data. To run a seismic imaging experiment on the aforementioned model, let's start by generating the seismic data. model0 = Model(n, d, o, m0; nb = 80) model = Model(n, d, o, m; nb = 80) Here, \\(\\mathbf{m}\\) and \\(\\mathbf{m}_0\\) are stored in model structure in JUDI, with metadata (e.g. number of grid points, dimension, spacing etc). We then set up the source geometry and receiver geometry as below. Notice that the numerical simulations here are in 2D, so \\(y\\) -direction is always \\(0\\) . nsrc = 8 # num of sources xsrc = range(900f0, stop=1100f0, length=nsrc) # in [m] ysrc = range(0f0, stop=0f0, length=nsrc) # in [m] zsrc = range(6f0, stop=6f0, length=nsrc) # in [m] timeS = 1000f0 # source injection time [ms] dtS = 1f0 # time sampling [ms] ntS = Int(timeS/dtS) + 1 # number of time samples srcGeometry = Geometry(convertToCell(xsrc),convertToCell(ysrc),convertToCell(zsrc); dt=dtS, t=timeS) nrec = 100 # num of receivers xrec = range(d[1], stop=(n[1]-1)*d[1], length=nrec) # in [m] yrec = 0f0 # in [m] zrec = range(10f0, stop=10f0, length=nrec) # in [m] timeR = 1000f0 # recording time [ms] dtR = 1f0 # time sampling [ms] ntR = Int(timeR/dtR) + 1 # number of time samples recGeometry = Geometry(xrec,yrec,zrec;dt=dtR,t=timeR, nsrc=nsrc) Set up the source with Ricker wavelet f0 = 0.015f0 # 15 Hz wavelet wavelet = ricker_wavelet(timeS, dtS, f0) q = judiVector(srcGeometry, wavelet) # source Set up computational time step # Set up info structure for linear operators ntComp = get_computational_nt(srcGeometry, recGeometry, model) info = Info(prod(n), nsrc, ntComp) Set up forward modeling operators in ground truth velocity, background velocity, and migration operator --- these are linear operators!! F = judiModeling(info, model, srcGeometry, recGeometry; options=Options(isic=true)) # forward modeling w/ true model F0 = judiModeling(info, model0, srcGeometry, recGeometry; options=Options(isic=true)) # forward modeling w/ background model J = judiJacobian(F0,q) # demigration operator (adjoint of J is migration) Task: please plot the sources/receivers overlaying on the true velocity model. Use scatter to plot scatter points in an image. Where are the sources and receivers? Generate data Generate data in ground truth velocity and background velocity dobs = F*q dobs0 = F0*q Task: plot a single shot record of dobs and dobs0 . Choose the same source. What do you see in the shot record? If there are a couple of events, try to match them up with the corresponding reflectors. # hint: seismic data is as a judiVector # you can access its value by, e.g. figure(figsize=(20,12));imshow(dobs.data[1],extent=(1, nrec, (ntR-1)*dtR, 0f0), vmin=-0.02*norm(dobs.data[1],Inf),cmap=\"seismic\",vmax=0.02*norm(dobs.data[1],Inf),aspect=\"auto\") xlabel(\"receiver no.\");ylabel(\"[ms]\"); # This plots the shot record in correct velocity generated by the 1st source You can also generate a linearized shot record by dlin = J*dm Task: plot a shot record from dlin and dobs-dobs0 . What do you see? Why do you observe this theoretically (think about math)? Reverse time migration (RTM) From now on, we will only focusing on imaging the linearized data for simplicity. First, we can try reverse time migration by rtm = J'*dlin Task: compare RTM results w/ the correct squared slowness perturbation dm , what do you see and what is your interpretation on the result? # hint: rtm is not a matrix, but a PhysicalParameters (a data structure). Do rtm.data to access the value. Again take care of vmin, vmax, aspect of plotting. Least-squares reverse time migration (LS-RTM) Seismic imaging researchers are not always satisfied with RTM. Seismic imaging basically solves the optimization problem \\(\\min_{\\mathbf{\\delta m}} \\|\\mathbf{J}\\mathbf{\\delta m} - \\mathbf{\\delta d}\\|_2^2\\) where RTM is only taking a full gradient of the objective w.r.t. \\(\\delta \\mathbf{m}\\) . To get better images, we can minimize the objective by LSQR and apply a right preconditioner # Right Preconditioner Tm = judiTopmute(model0.n, 19, 2) # Mute water column S = judiDepthScaling(model0) Mr = S*Tm ## vanilla LSQR x1 = 0f0 .* model0.m lsqr!(x1,J*Mr,dlin;maxiter=2,atol=0f0,verbose=true) The final solution is given by Mr*x1 ( Mr is a right preconditioner so we are actually solving \\(\\min_{\\mathbf{x}}\\|\\mathbf{J}\\mathbf{M}_r\\mathbf{x}- \\mathbf{\\delta d}\\|_2^2\\) ) Task: compare LS-RTM result with the previous RTM result, what do you see? Sparsity-promoting least-squares reverse time migration (SPLS-RTM) The start-of-the-art imaging technique is to do LS-RTM while promoting sparsity of solution in Curvelet domain, see Witte et al . This can be achieved by linearized Bregman iterations, as shown below # Soft thresholding functions and Curvelet transform soft_thresholding(x::Array{Float64}, lambda) = sign.(x) .* max.(abs.(x) .- convert(Float64, lambda), 0.0) soft_thresholding(x::Array{Float32}, lambda) = sign.(x) .* max.(abs.(x) .- convert(Float32, lambda), 0f0) C = joCurvelet2D(n[1], n[2]; zero_finest = false, DDT = Float32, RDT = Float64) src_list = Set(collect(1:nsrc)) batchsize = 2 lambda = 0f0 x2 = 0f0 .* model0.m z = deepcopy(x2) niter = 8 # Main loop for j = 1:niter # Select batch and set up left-hand preconditioner length(src_list) < batchsize && (global src_list = Set(collect(1:nsrc))) i = [pop!(src_list) for b=1:batchsize] println(\"LS-RTM Iteration: $(j), imaging sources $(i)\") residual = J[i]*Mr*x2-dlin[i] phi = 0.5 * norm(residual)^2 g = Mr'*J[i]'*residual # Step size and update variable t = Float32.(2*phi/norm(g)^2) # Update variables and save snapshot global z -= t*g C_z = C*z (j==1) && (global lambda = quantile(abs.(C_z), .6)) # estimate thresholding parameter in 1st iteration global x2 = adjoint(C)*soft_thresholding(C_z, lambda) @printf(\"At iteration %d function value is %2.2e and step length is %2.2e \\n\", j, phi, t) @printf(\"Lambda is %2.2e \\n\", lambda) end The solution is given by Mr*x2 . Task: try to explain what every line in the for-loop does, i.e. what is it calculating. You can also refer to Algorithm 2 in this paper for more details/explanations. If you have any question, let Francis know : ) Task: Juxtapose 4 images: the true dm , the RTM result, the LS-RTM result from LSQR, the sparsity-promoting LS-RTM from Linearized Bregman. What do you see? Remember, our goal is to get an image that is similar to the true dm . Task: The seismic images (except for the true dm ) above are focusing mainly in the central region. Why? (Hint: check source/receiver locations) How can we get a full illumination of the image? Make experiments to verify. Task: change acquisition to be transmission -- e.g. put sources as a vertical line on the left, receivers on the right. Show what RTM image looks like. Describe your observations and try to interpret the result. Is it the same as you got from the reflection geometry?","title":"Homework 4 : Seismic imaging"},{"location":"Assignments/Exercise7/#homework-4-seismic-imaging","text":"In this exercise, we conduct a small 2D seismic imaging experiment on a 4-layer model example with JUDI . We suggest you use a Docker image to run the experiment so that software packages are properly installed. To use the docker image, first install docker. Then, in the terminal, do docker run -p 8888:8888 ziyiyin97/ccs-env:v4.4 Running this command will produce an output that looks like Copy/paste this URL into your browser when you connect for the first time, to login with a token: http://af637030c092:8888/?token=8f6c664eb945f9c6b7cd72669fef04a6dc70c08194cb87e9 or http://127.0.0.1:8888/?token=8f6c664eb945f9c6b7cd72669fef04a6dc70c08194cb87e9 Copy paste the URL in your browser and replace (af637030c092 or 127.0.0.1) by localhost . You will then be directed to a jupyter folder that contains the notebooks for the projects. Then, we can create a new julia script and run the experiment in it. A couple of things before we go into the details:","title":"Homework 4 : Seismic imaging"},{"location":"Assignments/Exercise7/#1-try-to-give-your-interpretation-to-every-figure-you-plot-what-is-each-event-in-the-figure","text":"","title":"1. Try to give your interpretation to every figure you plot. What is each event in the figure?"},{"location":"Assignments/Exercise7/#2-plotting-is-hard-when-you-make-plots-make-sure-you-use-the-correct-labels-and-units-so-that-images-are-in-meters-data-is-in-seconds-also-make-sure-you-clip-the-image-by-vmin-and-vmax-keywords-in-imshow-function-so-that-you-see-all-the-events-in-the-image","text":"","title":"2. Plotting is hard. When you make plots, make sure you use the correct labels and units so that images are in meters, data is in seconds. Also make sure you clip the image by vmin and vmax keywords in imshow function so that you see all the events in the image."},{"location":"Assignments/Exercise7/#3-to-plot-seismic-data-and-images-eg-rtm-we-always-put-vmin-vmax-so-that-0-is-at-the-center-in-your-colorscale-generally-we-use-cmapseismic-to-plot-seismic-data-cmapgreys-to-plot-seismic-images","text":"","title":"3. To plot seismic data and images (e.g. RTM), we always put vmin = -vmax so that \\(0\\) is at the center in your colorscale. Generally, we use cmap=\"seismic\" to plot seismic data, cmap=\"Greys\" to plot seismic images."},{"location":"Assignments/Exercise7/#lets-start","text":"First we load the packages as usual. ## First do using Pkg; Pkg.add(xxx) in case any package is not installed yet using JUDI, PyPlot, Images, JOLI, IterativeSolvers, LinearAlgebra, Printf, Statistics Here, we set up a \\(4\\) -layer model. The velocities in each layer are \\(1.5/2.5/3/3.5\\) km/s. We often call the first layer as the water layer/column in marine acquisition and assume to know its depth. # number of gridpoints n = (201, 101) # Grid spacing d = (10f0, 10f0) # in [m] # Origin o = (0f0, 0f0) # in [m] # Extent extent = (o[1], o[1]+(n[1]-1)*d[1], o[2]+(n[2]-1)*d[2], o[2]) # in [m] # Velocity [km/s] v = ones(Float32,n) .+ 0.5f0 v[:,20:50] .= 2.5f0 v[:,51:71] .= 3f0 v[:,71:end] .= 3.5f0 Wave-equation simulations in JUDI are parameterized by squared slowness \\(\\mathbf{m}\\) . For migration, we make up a background model \\(\\mathbf{m}_0\\) as a smoothed version of the ground truth one. To make things simple, we assume to use the exact water layer in the background model. The squared slowness perturbation \\(\\delta\\mathbf{m}\\) , as the difference of \\(\\mathbf{m}\\) and \\(\\mathbf{m}_0\\) , only contains the sharp reflectors. # Slowness squared [s^2/km^2] m = (1f0 ./ v).^2 m0 = deepcopy(m) m0[:,20:end] = convert(Array{Float32,2},imfilter(m[:,20:end], Kernel.gaussian(5))) # smooth the true velocity to get m0 dm = vec(m - m0) figure(figsize=(20,12)); subplot(1,3,1) imshow(reshape(m,n)', extent=extent, interpolation=\"none\", cmap=\"jet\");title(\"m\") xlabel(\"X [m]\"); ylabel(\"Z [m]\"); subplot(1,3,2) imshow(reshape(m0,n)', extent=extent, interpolation=\"none\", cmap=\"jet\");title(\"m0\") xlabel(\"X [m]\"); ylabel(\"Z [m]\"); subplot(1,3,3) imshow(reshape(dm,n)', extent=extent, interpolation=\"none\",cmap=\"Greys\");title(\"dm\") xlabel(\"X [m]\"); ylabel(\"Z [m]\"); The goal of seismic imaging/migration is to acquire this \\(\\delta\\mathbf{m}\\) from seismic data. To run a seismic imaging experiment on the aforementioned model, let's start by generating the seismic data. model0 = Model(n, d, o, m0; nb = 80) model = Model(n, d, o, m; nb = 80) Here, \\(\\mathbf{m}\\) and \\(\\mathbf{m}_0\\) are stored in model structure in JUDI, with metadata (e.g. number of grid points, dimension, spacing etc). We then set up the source geometry and receiver geometry as below. Notice that the numerical simulations here are in 2D, so \\(y\\) -direction is always \\(0\\) . nsrc = 8 # num of sources xsrc = range(900f0, stop=1100f0, length=nsrc) # in [m] ysrc = range(0f0, stop=0f0, length=nsrc) # in [m] zsrc = range(6f0, stop=6f0, length=nsrc) # in [m] timeS = 1000f0 # source injection time [ms] dtS = 1f0 # time sampling [ms] ntS = Int(timeS/dtS) + 1 # number of time samples srcGeometry = Geometry(convertToCell(xsrc),convertToCell(ysrc),convertToCell(zsrc); dt=dtS, t=timeS) nrec = 100 # num of receivers xrec = range(d[1], stop=(n[1]-1)*d[1], length=nrec) # in [m] yrec = 0f0 # in [m] zrec = range(10f0, stop=10f0, length=nrec) # in [m] timeR = 1000f0 # recording time [ms] dtR = 1f0 # time sampling [ms] ntR = Int(timeR/dtR) + 1 # number of time samples recGeometry = Geometry(xrec,yrec,zrec;dt=dtR,t=timeR, nsrc=nsrc) Set up the source with Ricker wavelet f0 = 0.015f0 # 15 Hz wavelet wavelet = ricker_wavelet(timeS, dtS, f0) q = judiVector(srcGeometry, wavelet) # source Set up computational time step # Set up info structure for linear operators ntComp = get_computational_nt(srcGeometry, recGeometry, model) info = Info(prod(n), nsrc, ntComp) Set up forward modeling operators in ground truth velocity, background velocity, and migration operator --- these are linear operators!! F = judiModeling(info, model, srcGeometry, recGeometry; options=Options(isic=true)) # forward modeling w/ true model F0 = judiModeling(info, model0, srcGeometry, recGeometry; options=Options(isic=true)) # forward modeling w/ background model J = judiJacobian(F0,q) # demigration operator (adjoint of J is migration)","title":"Let's start!"},{"location":"Assignments/Exercise7/#task-please-plot-the-sourcesreceivers-overlaying-on-the-true-velocity-model-use-scatter-to-plot-scatter-points-in-an-image-where-are-the-sources-and-receivers","text":"","title":"Task: please plot the sources/receivers overlaying on the true velocity model. Use scatter to plot scatter points in an image. Where are the sources and receivers?"},{"location":"Assignments/Exercise7/#generate-data","text":"Generate data in ground truth velocity and background velocity dobs = F*q dobs0 = F0*q","title":"Generate data"},{"location":"Assignments/Exercise7/#task-plot-a-single-shot-record-of-dobs-and-dobs0-choose-the-same-source-what-do-you-see-in-the-shot-record-if-there-are-a-couple-of-events-try-to-match-them-up-with-the-corresponding-reflectors","text":"# hint: seismic data is as a judiVector # you can access its value by, e.g. figure(figsize=(20,12));imshow(dobs.data[1],extent=(1, nrec, (ntR-1)*dtR, 0f0), vmin=-0.02*norm(dobs.data[1],Inf),cmap=\"seismic\",vmax=0.02*norm(dobs.data[1],Inf),aspect=\"auto\") xlabel(\"receiver no.\");ylabel(\"[ms]\"); # This plots the shot record in correct velocity generated by the 1st source You can also generate a linearized shot record by dlin = J*dm","title":"Task: plot a single shot record of dobs and dobs0. Choose the same source. What do you see in the shot record? If there are a couple of events, try to match them up with the corresponding reflectors."},{"location":"Assignments/Exercise7/#task-plot-a-shot-record-from-dlin-and-dobs-dobs0-what-do-you-see-why-do-you-observe-this-theoretically-think-about-math","text":"","title":"Task: plot a shot record from dlin and dobs-dobs0. What do you see? Why do you observe this theoretically (think about math)?"},{"location":"Assignments/Exercise7/#reverse-time-migration-rtm","text":"From now on, we will only focusing on imaging the linearized data for simplicity. First, we can try reverse time migration by rtm = J'*dlin","title":"Reverse time migration (RTM)"},{"location":"Assignments/Exercise7/#task-compare-rtm-results-w-the-correct-squared-slowness-perturbation-dm-what-do-you-see-and-what-is-your-interpretation-on-the-result","text":"# hint: rtm is not a matrix, but a PhysicalParameters (a data structure). Do rtm.data to access the value. Again take care of vmin, vmax, aspect of plotting.","title":"Task: compare RTM results w/ the correct squared slowness perturbation dm, what do you see and what is your interpretation on the result?"},{"location":"Assignments/Exercise7/#least-squares-reverse-time-migration-ls-rtm","text":"Seismic imaging researchers are not always satisfied with RTM. Seismic imaging basically solves the optimization problem \\(\\min_{\\mathbf{\\delta m}} \\|\\mathbf{J}\\mathbf{\\delta m} - \\mathbf{\\delta d}\\|_2^2\\) where RTM is only taking a full gradient of the objective w.r.t. \\(\\delta \\mathbf{m}\\) . To get better images, we can minimize the objective by LSQR and apply a right preconditioner # Right Preconditioner Tm = judiTopmute(model0.n, 19, 2) # Mute water column S = judiDepthScaling(model0) Mr = S*Tm ## vanilla LSQR x1 = 0f0 .* model0.m lsqr!(x1,J*Mr,dlin;maxiter=2,atol=0f0,verbose=true) The final solution is given by Mr*x1 ( Mr is a right preconditioner so we are actually solving \\(\\min_{\\mathbf{x}}\\|\\mathbf{J}\\mathbf{M}_r\\mathbf{x}- \\mathbf{\\delta d}\\|_2^2\\) )","title":"Least-squares reverse time migration (LS-RTM)"},{"location":"Assignments/Exercise7/#task-compare-ls-rtm-result-with-the-previous-rtm-result-what-do-you-see","text":"","title":"Task: compare LS-RTM result with the previous RTM result, what do you see?"},{"location":"Assignments/Exercise7/#sparsity-promoting-least-squares-reverse-time-migration-spls-rtm","text":"The start-of-the-art imaging technique is to do LS-RTM while promoting sparsity of solution in Curvelet domain, see Witte et al . This can be achieved by linearized Bregman iterations, as shown below # Soft thresholding functions and Curvelet transform soft_thresholding(x::Array{Float64}, lambda) = sign.(x) .* max.(abs.(x) .- convert(Float64, lambda), 0.0) soft_thresholding(x::Array{Float32}, lambda) = sign.(x) .* max.(abs.(x) .- convert(Float32, lambda), 0f0) C = joCurvelet2D(n[1], n[2]; zero_finest = false, DDT = Float32, RDT = Float64) src_list = Set(collect(1:nsrc)) batchsize = 2 lambda = 0f0 x2 = 0f0 .* model0.m z = deepcopy(x2) niter = 8 # Main loop for j = 1:niter # Select batch and set up left-hand preconditioner length(src_list) < batchsize && (global src_list = Set(collect(1:nsrc))) i = [pop!(src_list) for b=1:batchsize] println(\"LS-RTM Iteration: $(j), imaging sources $(i)\") residual = J[i]*Mr*x2-dlin[i] phi = 0.5 * norm(residual)^2 g = Mr'*J[i]'*residual # Step size and update variable t = Float32.(2*phi/norm(g)^2) # Update variables and save snapshot global z -= t*g C_z = C*z (j==1) && (global lambda = quantile(abs.(C_z), .6)) # estimate thresholding parameter in 1st iteration global x2 = adjoint(C)*soft_thresholding(C_z, lambda) @printf(\"At iteration %d function value is %2.2e and step length is %2.2e \\n\", j, phi, t) @printf(\"Lambda is %2.2e \\n\", lambda) end The solution is given by Mr*x2 .","title":"Sparsity-promoting least-squares reverse time migration (SPLS-RTM)"},{"location":"Assignments/Exercise7/#task-try-to-explain-what-every-line-in-the-for-loop-does-ie-what-is-it-calculating-you-can-also-refer-to-algorithm-2-in-this-paper-for-more-detailsexplanations-if-you-have-any-question-let-francis-know","text":"","title":"Task: try to explain what every line in the for-loop does, i.e. what is it calculating. You can also refer to Algorithm 2 in this paper for more details/explanations. If you have any question, let Francis know : )"},{"location":"Assignments/Exercise7/#task-juxtapose-4-images-the-true-dm-the-rtm-result-the-ls-rtm-result-from-lsqr-the-sparsity-promoting-ls-rtm-from-linearized-bregman-what-do-you-see-remember-our-goal-is-to-get-an-image-that-is-similar-to-the-true-dm","text":"","title":"Task: Juxtapose 4 images: the true dm, the RTM result, the LS-RTM result from LSQR, the sparsity-promoting LS-RTM from Linearized Bregman. What do you see? Remember, our goal is to get an image that is similar to the true dm."},{"location":"Assignments/Exercise7/#task-the-seismic-images-except-for-the-true-dm-above-are-focusing-mainly-in-the-central-region-why-hint-check-sourcereceiver-locations-how-can-we-get-a-full-illumination-of-the-image-make-experiments-to-verify","text":"","title":"Task: The seismic images (except for the true dm) above are focusing mainly in the central region. Why? (Hint: check source/receiver locations) How can we get a full illumination of the image? Make experiments to verify."},{"location":"Assignments/Exercise7/#task-change-acquisition-to-be-transmission-eg-put-sources-as-a-vertical-line-on-the-left-receivers-on-the-right-show-what-rtm-image-looks-like-describe-your-observations-and-try-to-interpret-the-result-is-it-the-same-as-you-got-from-the-reflection-geometry","text":"","title":"Task: change acquisition to be transmission -- e.g. put sources as a vertical line on the left, receivers on the right. Show what RTM image looks like. Describe your observations and try to interpret the result. Is it the same as you got from the reflection geometry?"},{"location":"Assignments/Homework2/","text":"Fluid Flow Simulation Adapted from the tutorial of FwiFlow.jl package , Coupled Time-Lapse Full-Waveform Inversion for Subsurface Flow Problems Using Intrusive Automatic Differentiation Dongzhuo Li, Kailai Xu, Jerry M. Harris, Eric Darve Thanks for the help on Docker image set-up from Thomas J. Grady II Set-up First, we set up some functions and structures below for fluid simulation, relative permeability, and fluid flow simulation. const K_CONST = 9.869232667160130e-16 * 86400 * 1e3 const ALPHA = 1.0 const SRC_CONST = 86400.0 # const GRAV_CONST = 9.8 # gravity constant mutable struct Ctx m; n; h; NT; \u0394t; Z; X; \u03c1w; \u03c1o; \u03bcw; \u03bco; K; g; \u03d5; qw; qo; sw0 end function tfCtxGen(m,n,h,NT,\u0394t,Z,X,\u03c1w,\u03c1o,\u03bcw,\u03bco,K,g,\u03d5,qw,qo,sw0,ifTrue) tf_h = constant(h) # tf_NT = constant(NT) tf_\u0394t = constant(\u0394t) tf_Z = constant(Z) tf_X= constant(X) tf_\u03c1w = constant(\u03c1w) tf_\u03c1o = constant(\u03c1o) tf_\u03bcw = constant(\u03bcw) tf_\u03bco = constant(\u03bco) # tf_K = isa(K,Array) ? Variable(K) : K if ifTrue tf_K = constant(K) else tf_K = Variable(K) end tf_g = constant(g) # tf_\u03d5 = Variable(\u03d5) tf_\u03d5 = constant(\u03d5) tf_qw = constant(qw) tf_qo = constant(qo) tf_sw0 = constant(sw0) return Ctx(m,n,tf_h,NT,tf_\u0394t,tf_Z,tf_X,tf_\u03c1w,tf_\u03c1o,tf_\u03bcw,tf_\u03bco,tf_K,tf_g,tf_\u03d5,tf_qw,tf_qo,tf_sw0) end function Krw(Sw) return Sw ^ 1.5 end function Kro(So) return So ^1.5 end function ave_normal(quantity, m, n) aa = sum(quantity) return aa/(m*n) end ave_normal (generic function with 1 method) # variables : sw, u, v, p # (time dependent) parameters: qw, qo, \u03d5 function onestep(sw, p, m, n, h, \u0394t, Z, \u03c1w, \u03c1o, \u03bcw, \u03bco, K, g, \u03d5, qw, qo) # step 1: update p # \u03bbw = Krw(sw)/\u03bcw # \u03bbo = Kro(1-sw)/\u03bco \u03bbw = sw.*sw/\u03bcw \u03bbo = (1-sw).*(1-sw)/\u03bco \u03bb = \u03bbw + \u03bbo q = qw + qo + \u03bbw/(\u03bbo+1e-16).*qo # q = qw + qo potential_c = (\u03c1w - \u03c1o)*g .* Z # Step 1: implicit potential \u0398 = upwlap_op(K * K_CONST, \u03bbo, potential_c, h, constant(0.0)) load_normal = (\u0398+q/ALPHA) - ave_normal(\u0398+q/ALPHA, m, n) # p = poisson_op(\u03bb.*K* K_CONST, load_normal, h, constant(0.0), constant(1)) p = upwps_op(K * K_CONST, \u03bb, load_normal, p, h, constant(0.0), constant(0)) # potential p = pw - \u03c1w*g*h # step 2: implicit transport sw = sat_op(sw, p, K * K_CONST, \u03d5, qw, qo, \u03bcw, \u03bco, sw, \u0394t, h) return sw, p end function imseq(tf_ctx) ta_sw, ta_p = TensorArray(tf_ctx.NT+1), TensorArray(tf_ctx.NT+1) ta_sw = write(ta_sw, 1, tf_ctx.sw0) ta_p = write(ta_p, 1, constant(zeros(tf_ctx.m, tf_ctx.n))) i = constant(1, dtype=Int32) function condition(i, tas...) i <= tf_ctx.NT end function body(i, tas...) ta_sw, ta_p = tas sw, p = onestep(read(ta_sw, i), read(ta_p, i), tf_ctx.m, tf_ctx.n, tf_ctx.h, tf_ctx.\u0394t, tf_ctx.Z, tf_ctx.\u03c1w, tf_ctx.\u03c1o, tf_ctx.\u03bcw, tf_ctx.\u03bco, tf_ctx.K, tf_ctx.g, tf_ctx.\u03d5, tf_ctx.qw[i], tf_ctx.qo[i]) ta_sw = write(ta_sw, i+1, sw) ta_p = write(ta_p, i+1, p) i+1, ta_sw, ta_p end _, ta_sw, ta_p = while_loop(condition, body, [i, ta_sw, ta_p]) out_sw, out_p = stack(ta_sw), stack(ta_p) end imseq (generic function with 1 method) Below is the main flow function -- taking permeability, porosity, injection, production, and simulation grid as inputs function flow(K, \u03d5, qw, qo, grid; \u03c1w=501.9, \u03c1o=1053.0, \u03bcw=0.1, \u03bco=1.0, g=GRAV_CONST, S0=nothing) if isnothing(S0) S0 = zeros(grid.n[2], grid.n[1]) end qw = permutedims(qw, [1, 3, 2]) * (1/grid.h^2)/grid.hy * SRC_CONST qo = permutedims(qo, [1, 3, 2]) * (1/grid.h^2)/grid.hy * SRC_CONST K = K' \u03d5 = \u03d5' X = reshape(repeat((1:n[1])*grid.h, outer = n[2]), n[1], n[2])' Z = reshape(repeat((1:n[2])*grid.h, outer = n[1]), n[2], n[1]) tfCtxTrue = tfCtxGen(grid.n[2],grid.n[1],grid.h,grid.nt,grid.dt,Z,X,\u03c1w,\u03c1o,\u03bcw,\u03bco,K,g,\u03d5,qw,qo,S0,true) sp = imseq(tfCtxTrue) sess = Session(); init(sess) S, p = run(sess, sp) return permutedims(S, [1, 3, 2]), permutedims(p, [1, 3, 2]) end flow (generic function with 1 method) Main script The main script is here! We start by loading the Julia packages. The main simulation is done in FwiFlow using FwiFlow using PyCall using LinearAlgebra using PyPlot \u250c Warning: Cannot load /Users/francisyin/.julia/packages/ADCME/94vEM/deps/CustomOps/build/libadcme.dylib. Please recompile the shared library by `ADCME.precompile()` for using custom operators. \u2514 @ ADCME /Users/francisyin/.julia/packages/ADCME/94vEM/src/ADCME.jl:78 Next, let's set up the flow simulation parameters, i.e. the information of reservoir, injection etc. # Hyperparameter for flow simulation n = (30, 15) # domain of simulation (number of cells in x * number of cells in z) h = 30.0 # size of the cell (in meter) hy= 10.0 # width of the cell in y direction (now it's 2D code but CO2 lives in 3D space!) nt = 50 # number of time steps dt = 20 # time interval between 2 adjacent time steps (in day), you should NOT set this large otherwise the solver will be unstable mutable struct comp_grid # set up the grid structure n :: Tuple{Integer, Integer} # x, z h :: Float64 # meter hy :: Float64 # meter nt :: Integer dt :: Number # day end grid_ = comp_grid(n, h, hy, nt, dt) comp_grid((30, 15), 30.0, 10.0, 50, 20) Then let's set up the well information. In this software, there is assumed to be injection well(s) for CO2 injection and production well(s) for water production. qw = zeros(nt, n[1], n[2]); inj_loc = (3*h, 9*h); # injection location (at (3,9) cell in this case) qw[:,Int(round(inj_loc[1]/h)), Int(round(inj_loc[2]/h))] .= 0.005; # in [m^3/s] qo = zeros(nt, n[1], n[2]); prod_loc = (28*h, 9*h); # injection location (at (28,9) cell in this case) qo[:,Int(round(prod_loc[1]/h)),Int(round(prod_loc[2]/h))] .= -0.005; # also in [m^3/s] Then let's set up the permeability and porosity. \u03d5 = 0.25 .* ones(n); # porosity [0-1] K = 20.0 .* ones(n); # permeability [millidarcy] K[:,8:10] .= 120.0; # set a high permeability channel in the middle We can plot the permeability model and porosity model using PyPlot package. Its usage is quite similar to matplotlib in python (actually it's based on that) figure();imshow(K',extent=(0,n[1]*h,n[2]*h,0));title(\"Permeability [md]\"); xlabel(\"X [m]\");ylabel(\"Z [m]\"); colorbar(); scatter(inj_loc[1], inj_loc[2], marker=\".\", label=\"injection\") scatter(prod_loc[1], prod_loc[2], marker=\"x\", label=\"production\") legend(loc=3); \u250c Warning: `vendor()` is deprecated, use `BLAS.get_config()` and inspect the output instead \u2502 caller = npyinitialize() at numpy.jl:67 \u2514 @ PyCall /Users/francisyin/.julia/packages/PyCall/L0fLP/src/numpy.jl:67 figure();imshow(\u03d5',extent=(0,n[1]*h,n[2]*h,0));title(\"Porosity [100%]\"); xlabel(\"X [m]\");ylabel(\"Z [m]\"); colorbar(); scatter(inj_loc[1], inj_loc[2], marker=\".\", label=\"injection\") scatter(prod_loc[1], prod_loc[2], marker=\"x\", label=\"production\") legend(loc=3); Now let's run the flow simulation in 1 line! S, p = flow(K, \u03d5, qw, qo, grid_); \u001b[32mLoad library operator (with gradient, multiple outputs = false): /Users/francisyin/.julia/packages/FwiFlow/4kyhS/deps/CustomOps/Upwlap/build/libUpwlapOp.dylib ==> upwlap_op\u001b[39m \u001b[32mLoad library operator (with gradient, multiple outputs = false): /Users/francisyin/.julia/packages/FwiFlow/4kyhS/deps/CustomOps/Upwps/build/libUpwpsOp.dylib ==> upwps_op\u001b[39m \u001b[32mLoad library operator (with gradient, multiple outputs = false): /Users/francisyin/.julia/packages/FwiFlow/4kyhS/deps/CustomOps/Saturation/build/libSatOp.dylib ==> sat_op\u001b[39m 2022-02-03 11:08:40.343352: I tensorflow/core/platform/cpu_feature_guard.cc:142] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2 FMA 2022-02-03 11:08:40.369226: I tensorflow/compiler/xla/service/service.cc:168] XLA service 0x7fbea7857140 initialized for platform Host (this does not guarantee that XLA will be used). Devices: 2022-02-03 11:08:40.369239: I tensorflow/compiler/xla/service/service.cc:176] StreamExecutor device (0): Host, Default Version And then let's take a look at the CO2 saturation at various time steps. figure(figsize=(20,12)); obs = Int.(round.(range(1, stop=nt+1, length=9))); # 9 observed time samples for i = 1:9 subplot(3,3,i) imshow(S[obs[i], :, :]', extent=(0,n[1]*h,n[2]*h,0), vmin=0, vmax=1) xlabel(\"X [m]\");ylabel(\"Z [m]\"); colorbar() end suptitle(\"CO2 saturation [100%]\") PyObject Text(0.5, 0.98, 'CO2 saturation [100%]') TO-DO: Q1 What do you see in these time-varying CO2 saturation images? How do you interpret the movement of CO2? Calculate the amount of CO2 in the reservoir after 60 days of injection. Is it the same as the injection amount? (If not, why?) Calculate the capacity coefficient after 90 days of injection. Calculate the amount of CO2 in the reservoir at the end of injection. Is it the same as the injection amount? (If not, why?) Q2 Re-run this experiment with a homogeneous permeability model, i.e. remove the yellow high permeability channel in the middle. Plot the CO2 saturations with correct labels and colorbars. Compare them with the saturations with the high permeability channel. What do you see? How do you interpret the result? Q3 Re-run this experiment with the high permeability channel, but without the production well, i.e. make it 0. Plot the CO2 saturations with correct labels and colorbars. What do you see? How do you interpret the result?","title":"Fluid Flow Simulation"},{"location":"Assignments/Homework2/#fluid-flow-simulation","text":"Adapted from the tutorial of FwiFlow.jl package , Coupled Time-Lapse Full-Waveform Inversion for Subsurface Flow Problems Using Intrusive Automatic Differentiation Dongzhuo Li, Kailai Xu, Jerry M. Harris, Eric Darve Thanks for the help on Docker image set-up from Thomas J. Grady II","title":"Fluid Flow Simulation"},{"location":"Assignments/Homework2/#set-up","text":"","title":"Set-up"},{"location":"Assignments/Homework2/#first-we-set-up-some-functions-and-structures-below-for-fluid-simulation-relative-permeability-and-fluid-flow-simulation","text":"const K_CONST = 9.869232667160130e-16 * 86400 * 1e3 const ALPHA = 1.0 const SRC_CONST = 86400.0 # const GRAV_CONST = 9.8 # gravity constant mutable struct Ctx m; n; h; NT; \u0394t; Z; X; \u03c1w; \u03c1o; \u03bcw; \u03bco; K; g; \u03d5; qw; qo; sw0 end function tfCtxGen(m,n,h,NT,\u0394t,Z,X,\u03c1w,\u03c1o,\u03bcw,\u03bco,K,g,\u03d5,qw,qo,sw0,ifTrue) tf_h = constant(h) # tf_NT = constant(NT) tf_\u0394t = constant(\u0394t) tf_Z = constant(Z) tf_X= constant(X) tf_\u03c1w = constant(\u03c1w) tf_\u03c1o = constant(\u03c1o) tf_\u03bcw = constant(\u03bcw) tf_\u03bco = constant(\u03bco) # tf_K = isa(K,Array) ? Variable(K) : K if ifTrue tf_K = constant(K) else tf_K = Variable(K) end tf_g = constant(g) # tf_\u03d5 = Variable(\u03d5) tf_\u03d5 = constant(\u03d5) tf_qw = constant(qw) tf_qo = constant(qo) tf_sw0 = constant(sw0) return Ctx(m,n,tf_h,NT,tf_\u0394t,tf_Z,tf_X,tf_\u03c1w,tf_\u03c1o,tf_\u03bcw,tf_\u03bco,tf_K,tf_g,tf_\u03d5,tf_qw,tf_qo,tf_sw0) end function Krw(Sw) return Sw ^ 1.5 end function Kro(So) return So ^1.5 end function ave_normal(quantity, m, n) aa = sum(quantity) return aa/(m*n) end ave_normal (generic function with 1 method) # variables : sw, u, v, p # (time dependent) parameters: qw, qo, \u03d5 function onestep(sw, p, m, n, h, \u0394t, Z, \u03c1w, \u03c1o, \u03bcw, \u03bco, K, g, \u03d5, qw, qo) # step 1: update p # \u03bbw = Krw(sw)/\u03bcw # \u03bbo = Kro(1-sw)/\u03bco \u03bbw = sw.*sw/\u03bcw \u03bbo = (1-sw).*(1-sw)/\u03bco \u03bb = \u03bbw + \u03bbo q = qw + qo + \u03bbw/(\u03bbo+1e-16).*qo # q = qw + qo potential_c = (\u03c1w - \u03c1o)*g .* Z # Step 1: implicit potential \u0398 = upwlap_op(K * K_CONST, \u03bbo, potential_c, h, constant(0.0)) load_normal = (\u0398+q/ALPHA) - ave_normal(\u0398+q/ALPHA, m, n) # p = poisson_op(\u03bb.*K* K_CONST, load_normal, h, constant(0.0), constant(1)) p = upwps_op(K * K_CONST, \u03bb, load_normal, p, h, constant(0.0), constant(0)) # potential p = pw - \u03c1w*g*h # step 2: implicit transport sw = sat_op(sw, p, K * K_CONST, \u03d5, qw, qo, \u03bcw, \u03bco, sw, \u0394t, h) return sw, p end function imseq(tf_ctx) ta_sw, ta_p = TensorArray(tf_ctx.NT+1), TensorArray(tf_ctx.NT+1) ta_sw = write(ta_sw, 1, tf_ctx.sw0) ta_p = write(ta_p, 1, constant(zeros(tf_ctx.m, tf_ctx.n))) i = constant(1, dtype=Int32) function condition(i, tas...) i <= tf_ctx.NT end function body(i, tas...) ta_sw, ta_p = tas sw, p = onestep(read(ta_sw, i), read(ta_p, i), tf_ctx.m, tf_ctx.n, tf_ctx.h, tf_ctx.\u0394t, tf_ctx.Z, tf_ctx.\u03c1w, tf_ctx.\u03c1o, tf_ctx.\u03bcw, tf_ctx.\u03bco, tf_ctx.K, tf_ctx.g, tf_ctx.\u03d5, tf_ctx.qw[i], tf_ctx.qo[i]) ta_sw = write(ta_sw, i+1, sw) ta_p = write(ta_p, i+1, p) i+1, ta_sw, ta_p end _, ta_sw, ta_p = while_loop(condition, body, [i, ta_sw, ta_p]) out_sw, out_p = stack(ta_sw), stack(ta_p) end imseq (generic function with 1 method)","title":"First, we set up some functions and structures below for fluid simulation, relative permeability, and fluid flow simulation."},{"location":"Assignments/Homework2/#below-is-the-main-flow-function-taking-permeability-porosity-injection-production-and-simulation-grid-as-inputs","text":"function flow(K, \u03d5, qw, qo, grid; \u03c1w=501.9, \u03c1o=1053.0, \u03bcw=0.1, \u03bco=1.0, g=GRAV_CONST, S0=nothing) if isnothing(S0) S0 = zeros(grid.n[2], grid.n[1]) end qw = permutedims(qw, [1, 3, 2]) * (1/grid.h^2)/grid.hy * SRC_CONST qo = permutedims(qo, [1, 3, 2]) * (1/grid.h^2)/grid.hy * SRC_CONST K = K' \u03d5 = \u03d5' X = reshape(repeat((1:n[1])*grid.h, outer = n[2]), n[1], n[2])' Z = reshape(repeat((1:n[2])*grid.h, outer = n[1]), n[2], n[1]) tfCtxTrue = tfCtxGen(grid.n[2],grid.n[1],grid.h,grid.nt,grid.dt,Z,X,\u03c1w,\u03c1o,\u03bcw,\u03bco,K,g,\u03d5,qw,qo,S0,true) sp = imseq(tfCtxTrue) sess = Session(); init(sess) S, p = run(sess, sp) return permutedims(S, [1, 3, 2]), permutedims(p, [1, 3, 2]) end flow (generic function with 1 method)","title":"Below is the main flow function -- taking permeability, porosity, injection, production, and simulation grid as inputs"},{"location":"Assignments/Homework2/#main-script","text":"The main script is here! We start by loading the Julia packages. The main simulation is done in FwiFlow using FwiFlow using PyCall using LinearAlgebra using PyPlot \u250c Warning: Cannot load /Users/francisyin/.julia/packages/ADCME/94vEM/deps/CustomOps/build/libadcme.dylib. Please recompile the shared library by `ADCME.precompile()` for using custom operators. \u2514 @ ADCME /Users/francisyin/.julia/packages/ADCME/94vEM/src/ADCME.jl:78","title":"Main script"},{"location":"Assignments/Homework2/#next-lets-set-up-the-flow-simulation-parameters-ie-the-information-of-reservoir-injection-etc","text":"# Hyperparameter for flow simulation n = (30, 15) # domain of simulation (number of cells in x * number of cells in z) h = 30.0 # size of the cell (in meter) hy= 10.0 # width of the cell in y direction (now it's 2D code but CO2 lives in 3D space!) nt = 50 # number of time steps dt = 20 # time interval between 2 adjacent time steps (in day), you should NOT set this large otherwise the solver will be unstable mutable struct comp_grid # set up the grid structure n :: Tuple{Integer, Integer} # x, z h :: Float64 # meter hy :: Float64 # meter nt :: Integer dt :: Number # day end grid_ = comp_grid(n, h, hy, nt, dt) comp_grid((30, 15), 30.0, 10.0, 50, 20)","title":"Next, let's set up the flow simulation parameters, i.e. the information of reservoir, injection etc."},{"location":"Assignments/Homework2/#then-lets-set-up-the-well-information-in-this-software-there-is-assumed-to-be-injection-wells-for-co2-injection-and-production-wells-for-water-production","text":"qw = zeros(nt, n[1], n[2]); inj_loc = (3*h, 9*h); # injection location (at (3,9) cell in this case) qw[:,Int(round(inj_loc[1]/h)), Int(round(inj_loc[2]/h))] .= 0.005; # in [m^3/s] qo = zeros(nt, n[1], n[2]); prod_loc = (28*h, 9*h); # injection location (at (28,9) cell in this case) qo[:,Int(round(prod_loc[1]/h)),Int(round(prod_loc[2]/h))] .= -0.005; # also in [m^3/s]","title":"Then let's set up the well information. In this software, there is assumed to be injection well(s) for CO2 injection and production well(s) for water production."},{"location":"Assignments/Homework2/#then-lets-set-up-the-permeability-and-porosity","text":"\u03d5 = 0.25 .* ones(n); # porosity [0-1] K = 20.0 .* ones(n); # permeability [millidarcy] K[:,8:10] .= 120.0; # set a high permeability channel in the middle","title":"Then let's set up the permeability and porosity."},{"location":"Assignments/Homework2/#we-can-plot-the-permeability-model-and-porosity-model-using-pyplot-package-its-usage-is-quite-similar-to-matplotlib-in-python-actually-its-based-on-that","text":"figure();imshow(K',extent=(0,n[1]*h,n[2]*h,0));title(\"Permeability [md]\"); xlabel(\"X [m]\");ylabel(\"Z [m]\"); colorbar(); scatter(inj_loc[1], inj_loc[2], marker=\".\", label=\"injection\") scatter(prod_loc[1], prod_loc[2], marker=\"x\", label=\"production\") legend(loc=3); \u250c Warning: `vendor()` is deprecated, use `BLAS.get_config()` and inspect the output instead \u2502 caller = npyinitialize() at numpy.jl:67 \u2514 @ PyCall /Users/francisyin/.julia/packages/PyCall/L0fLP/src/numpy.jl:67 figure();imshow(\u03d5',extent=(0,n[1]*h,n[2]*h,0));title(\"Porosity [100%]\"); xlabel(\"X [m]\");ylabel(\"Z [m]\"); colorbar(); scatter(inj_loc[1], inj_loc[2], marker=\".\", label=\"injection\") scatter(prod_loc[1], prod_loc[2], marker=\"x\", label=\"production\") legend(loc=3);","title":"We can plot the permeability model and porosity model using PyPlot package. Its usage is quite similar to matplotlib in python (actually it's based on that)"},{"location":"Assignments/Homework2/#now-lets-run-the-flow-simulation-in-1-line","text":"S, p = flow(K, \u03d5, qw, qo, grid_); \u001b[32mLoad library operator (with gradient, multiple outputs = false): /Users/francisyin/.julia/packages/FwiFlow/4kyhS/deps/CustomOps/Upwlap/build/libUpwlapOp.dylib ==> upwlap_op\u001b[39m \u001b[32mLoad library operator (with gradient, multiple outputs = false): /Users/francisyin/.julia/packages/FwiFlow/4kyhS/deps/CustomOps/Upwps/build/libUpwpsOp.dylib ==> upwps_op\u001b[39m \u001b[32mLoad library operator (with gradient, multiple outputs = false): /Users/francisyin/.julia/packages/FwiFlow/4kyhS/deps/CustomOps/Saturation/build/libSatOp.dylib ==> sat_op\u001b[39m 2022-02-03 11:08:40.343352: I tensorflow/core/platform/cpu_feature_guard.cc:142] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2 FMA 2022-02-03 11:08:40.369226: I tensorflow/compiler/xla/service/service.cc:168] XLA service 0x7fbea7857140 initialized for platform Host (this does not guarantee that XLA will be used). Devices: 2022-02-03 11:08:40.369239: I tensorflow/compiler/xla/service/service.cc:176] StreamExecutor device (0): Host, Default Version","title":"Now let's run the flow simulation in 1 line!"},{"location":"Assignments/Homework2/#and-then-lets-take-a-look-at-the-co2-saturation-at-various-time-steps","text":"figure(figsize=(20,12)); obs = Int.(round.(range(1, stop=nt+1, length=9))); # 9 observed time samples for i = 1:9 subplot(3,3,i) imshow(S[obs[i], :, :]', extent=(0,n[1]*h,n[2]*h,0), vmin=0, vmax=1) xlabel(\"X [m]\");ylabel(\"Z [m]\"); colorbar() end suptitle(\"CO2 saturation [100%]\") PyObject Text(0.5, 0.98, 'CO2 saturation [100%]')","title":"And then let's take a look at the CO2 saturation at various time steps."},{"location":"Assignments/Homework2/#to-do","text":"","title":"TO-DO:"},{"location":"Assignments/Homework2/#q1","text":"What do you see in these time-varying CO2 saturation images? How do you interpret the movement of CO2? Calculate the amount of CO2 in the reservoir after 60 days of injection. Is it the same as the injection amount? (If not, why?) Calculate the capacity coefficient after 90 days of injection. Calculate the amount of CO2 in the reservoir at the end of injection. Is it the same as the injection amount? (If not, why?)","title":"Q1"},{"location":"Assignments/Homework2/#q2","text":"Re-run this experiment with a homogeneous permeability model, i.e. remove the yellow high permeability channel in the middle. Plot the CO2 saturations with correct labels and colorbars. Compare them with the saturations with the high permeability channel. What do you see? How do you interpret the result?","title":"Q2"},{"location":"Assignments/Homework2/#q3","text":"Re-run this experiment with the high permeability channel, but without the production well, i.e. make it 0. Plot the CO2 saturations with correct labels and colorbars. What do you see? How do you interpret the result?","title":"Q3"},{"location":"Assignments/homework1/","text":"Homework 1 Q1 Please explain what is happening on an atomic or molecular scale that causes the phenomenon of surface tension. In particular, why is the meniscus for water in a vertical capillary tube concave and that for mercury convex? Q2 Assume a reservoir has homogeneous density denoted by \\(\\rho\\) and homogeneous porosity denoted by \\(\\phi\\) . Initially, the pore spaces of the rocks in the reservoir is entirely filled with water. We now inject supercritical CO \\(_2\\) into the reservoir to replace water, and denote the saturation of CO \\(_2\\) as \\(S\\) ( \\(0\\leq S\\leq 1\\) ). Please be careful that \\(\\rho\\) is the density of rock filled with water, not the density of rock itself. Suppose \\(\\phi=0.3\\) , \\(\\rho=3000\\) kg/m \\(^3\\) before injection. Please plot how \\(\\rho\\) changes with different values of CO \\(_2\\) saturations. What is the shape of the curve? Now change \\(\\rho=2000\\) kg/m \\(^3\\) . Do the same experiment. What is the shape? Can you compare this curve to the previous one? Now we stick to \\(\\phi=0.3\\) , \\(\\rho=3000\\) kg/m \\(^3\\) , but inject another fluid as you like -- gas, milk, belgium beer, liquid mercury, coca cola, etc. Do the same experiment. Compare this curve to the curve you got from the first one. Q3 Drawing inspiration from A. Donev et al., Improving the Density of Jammed Disordered Packings Using Ellipsoids, Science, 303, 990--993 (2004) D.A. Weitz, acking in the Spheres, Science, 303, 968--969 (2004); measure the porosity of a random close packing of M&M's. Verify your result by bringing your particular collection of M&M's to class. You can work with other kinds of cookie packs as you like. (In addition, a brief report on your experiment, including a short discussion of how your result agrees or disagrees with what is presented in the above articles, is required.)","title":"Homework 1"},{"location":"Assignments/homework1/#homework-1","text":"","title":"Homework 1"},{"location":"Assignments/homework1/#q1","text":"Please explain what is happening on an atomic or molecular scale that causes the phenomenon of surface tension. In particular, why is the meniscus for water in a vertical capillary tube concave and that for mercury convex?","title":"Q1"},{"location":"Assignments/homework1/#q2","text":"Assume a reservoir has homogeneous density denoted by \\(\\rho\\) and homogeneous porosity denoted by \\(\\phi\\) . Initially, the pore spaces of the rocks in the reservoir is entirely filled with water. We now inject supercritical CO \\(_2\\) into the reservoir to replace water, and denote the saturation of CO \\(_2\\) as \\(S\\) ( \\(0\\leq S\\leq 1\\) ). Please be careful that \\(\\rho\\) is the density of rock filled with water, not the density of rock itself. Suppose \\(\\phi=0.3\\) , \\(\\rho=3000\\) kg/m \\(^3\\) before injection. Please plot how \\(\\rho\\) changes with different values of CO \\(_2\\) saturations. What is the shape of the curve? Now change \\(\\rho=2000\\) kg/m \\(^3\\) . Do the same experiment. What is the shape? Can you compare this curve to the previous one? Now we stick to \\(\\phi=0.3\\) , \\(\\rho=3000\\) kg/m \\(^3\\) , but inject another fluid as you like -- gas, milk, belgium beer, liquid mercury, coca cola, etc. Do the same experiment. Compare this curve to the curve you got from the first one.","title":"Q2"},{"location":"Assignments/homework1/#q3","text":"Drawing inspiration from A. Donev et al., Improving the Density of Jammed Disordered Packings Using Ellipsoids, Science, 303, 990--993 (2004) D.A. Weitz, acking in the Spheres, Science, 303, 968--969 (2004); measure the porosity of a random close packing of M&M's. Verify your result by bringing your particular collection of M&M's to class. You can work with other kinds of cookie packs as you like. (In addition, a brief report on your experiment, including a short discussion of how your result agrees or disagrees with what is presented in the above articles, is required.)","title":"Q3"},{"location":"Assignments/introduction_to_julia/","text":"A quick introduction to the Julia language Getting started Start an interactive Julia session by running julia from the command line. You can quit the session with exit(). Generally, all functions in Julia are run using parenthesis, even if there are no input arguments. pwd() \"/home/yzhang3198\" You can define Julia scripts as regular text files that end with .jl and use your favourite text editor to code. Once you have your script, e.g.: hello-world.jl println(\"Hello world\") Hello world you can run the script with include(\"hello-world.jl\"). The Julia REPL REPL stands for Read/Evaluate/Print/Loop and refers to the interactive Julia session (it's just like a Matlab session). It's good for experimenting, but any serious coding should be done using scripts instead. 42 42 4+5 9 Unlike Matlab, you can access Julia's help functions by typing the question mark, followed by the function that you want the documention of: ? exit search: \u001b[0m\u001b[1me\u001b[22m\u001b[0m\u001b[1mx\u001b[22m\u001b[0m\u001b[1mi\u001b[22m\u001b[0m\u001b[1mt\u001b[22m at\u001b[0m\u001b[1me\u001b[22m\u001b[0m\u001b[1mx\u001b[22m\u001b[0m\u001b[1mi\u001b[22m\u001b[0m\u001b[1mt\u001b[22m t\u001b[0m\u001b[1me\u001b[22m\u001b[0m\u001b[1mx\u001b[22mtw\u001b[0m\u001b[1mi\u001b[22md\u001b[0m\u001b[1mt\u001b[22mh proc\u001b[0m\u001b[1me\u001b[22mss_e\u001b[0m\u001b[1mx\u001b[22m\u001b[0m\u001b[1mi\u001b[22m\u001b[0m\u001b[1mt\u001b[22med ind\u001b[0m\u001b[1me\u001b[22m\u001b[0m\u001b[1mx\u001b[22m\u001b[0m\u001b[1mi\u001b[22mn n\u001b[0m\u001b[1me\u001b[22m\u001b[0m\u001b[1mx\u001b[22mt\u001b[0m\u001b[1mi\u001b[22mnd Ind\u001b[0m\u001b[1me\u001b[22m\u001b[0m\u001b[1mx\u001b[22mL\u001b[0m\u001b[1mi\u001b[22mnear exit(code=0) Stop the program with an exit code. The default exit code is zero, indicating that the program completed successfully. In an interactive session, exit() can be called with the keyboard shortcut ^D . exit() Quit the program indicating that the processes completed successfully. This function calls exit(0) (see exit). Similarly, you can enter the shell mode by typing ;, which gives you access to a full bash terminal. ; pwd /home/yzhang3198 In contrast to Matlab, Julia treats all operators as functions. This means you can add two numbers in either of the two ways: a = 4 + 5 9 a = +(4, 5) 9 The same applies for any other operations, such as subtraction, multiplications etc. Some math constants are defined in Julia by default, such as: print(pi) \u03c0 Julia was designed with the intend to write code that resembles mathematics as close as possible. For example, you can omit the multiplication operator when working with variables: x = 5 2x + 4 # which is the same as 2*x + 4 14 Just as Matlab, but different than Python, Julia comes with many built-in math functions that you would need for everyday use: sin(pi / 2) 1.0 log(100) 4.605170185988092 exp(4.3) 73.69979369959579 rand() 0.24072220081526052 Packages and Plotting Packages provide additional functionalities, that are not included in core Julia. Packages are written both by official Julia programmers, as well as anyone else who programs in Julia. Since native Julia does not include any plotting tools, we have to download a third-party package, such as PyPlot or Plots: using Pkg Pkg.add(\"PyPlot\") \u001b[32m\u001b[1m Updating\u001b[22m\u001b[39m registry at `~/.julia/registries/General` \u001b[32m\u001b[1m Updating\u001b[22m\u001b[39m git-repo `https://github.com/JuliaRegistries/General.git` \u001b[2K\u001b[?25h[1mFetching:\u001b[22m\u001b[39m [========================================>] 99.9 %0.0 %] 14.5 %============> ] 29.0 %43.4 %> ] 57.9 % [=============================> ] 72.4 %86.7 %\u001b[32m\u001b[1m Resolving\u001b[22m\u001b[39m package versions... \u001b[32m\u001b[1m Installed\u001b[22m\u001b[39m AWSS3 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 v0.6.6 \u001b[32m\u001b[1m Installed\u001b[22m\u001b[39m AbstractTrees \u2500\u2500 v0.3.1 \u001b[32m\u001b[1m Installed\u001b[22m\u001b[39m DataStructures \u2500 v0.17.9 \u001b[32m\u001b[1m Installed\u001b[22m\u001b[39m ZMQ \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 v1.1.0 \u001b[32m\u001b[1m Installed\u001b[22m\u001b[39m NNlib \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 v0.6.4 \u001b[32m\u001b[1m Installed\u001b[22m\u001b[39m ForwardDiff \u2500\u2500\u2500\u2500 v0.10.9 \u001b[32m\u001b[1m Updating\u001b[22m\u001b[39m `~/.julia/environments/v1.2/Project.toml` \u001b[90m [no changes]\u001b[39m \u001b[32m\u001b[1m Updating\u001b[22m\u001b[39m `~/.julia/environments/v1.2/Manifest.toml` \u001b[90m [1c724243]\u001b[39m\u001b[93m \u2191 AWSS3 v0.6.5 \u21d2 v0.6.6\u001b[39m \u001b[90m [1520ce14]\u001b[39m\u001b[93m \u2191 AbstractTrees v0.2.1 \u21d2 v0.3.1\u001b[39m \u001b[90m [864edb3b]\u001b[39m\u001b[93m \u2191 DataStructures v0.17.7 \u21d2 v0.17.9\u001b[39m \u001b[90m [f6369f11]\u001b[39m\u001b[93m \u2191 ForwardDiff v0.10.8 \u21d2 v0.10.9\u001b[39m \u001b[90m [872c559c]\u001b[39m\u001b[93m \u2191 NNlib v0.6.2 \u21d2 v0.6.4\u001b[39m \u001b[90m [c2297ded]\u001b[39m\u001b[93m \u2191 ZMQ v1.0.0 \u21d2 v1.1.0\u001b[39m \u001b[32m\u001b[1m Building\u001b[22m\u001b[39m ZMQ \u2500\u2500\u2192 `~/.julia/packages/ZMQ/ItfqT/deps/build.log` \u001b[32m\u001b[1m Building\u001b[22m\u001b[39m NNlib \u2192 `~/.julia/packages/NNlib/3krvM/deps/build.log` Once you have downloaded a package, you can use it by typing: using PyPlot \u250c Info: Recompiling stale cache file /home/yzhang3198/.julia/compiled/v1.2/PyPlot/oatAj.ji for PyPlot [d330b81b-6aea-500a-939a-2ce795aea3ee] \u2514 @ Base loading.jl:1240 This plotting package is based off Python's Matplotlib package and therefore shares much of the Syntax. Some common plotting commands include: x = 1:100; f = x .^ 2; plot(x, f) 1-element Array{PyCall.PyObject,1}: PyObject <matplotlib.lines.Line2D object at 0x7fdfe39703c8> A = randn(20,30); imshow(A, extent=[0,30,20,40]) PyObject <matplotlib.image.AxesImage object at 0x7fdfe32bcef0> Arrays and tuples Arrays are defined in a similar fashion to Matlab: x = [1, 2, 3, 4, 5] 5-element Array{Int64,1}: 1 2 3 4 5 As you can see from the output on the screen, Julia actually cares about types of variables and arrays. Since we defined our array as a collection of integers, the type of our array is `{Int64,1} y = [1., 2., 3., 4., 5.] 5-element Array{Float64,1}: 1.0 2.0 3.0 4.0 5.0 You can make a vector out of anything, not just numbers. For example, you can collect strings in a vector like this: s = [\"This\", \"is\", \"a\", \"string\", \"vector\"] 5-element Array{String,1}: \"This\" \"is\" \"a\" \"string\" \"vector\" s = [\"string\", 4.0, sin, pi] 4-element Array{Any,1}: \"string\" 4.0 sin \u03c0 Multi-dimensional arrays are formed as follows: A = [1 2 3 4; 5 6 7 8] 2\u00d74 Array{Int64,2}: 1 2 3 4 5 6 7 8 Note that entries of the same row are separated by spaces and rows are separated by ; You can also initialize vectors/matrices of a given dimension in various ways: B = zeros(4,5) 4\u00d75 Array{Float64,2}: 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 C = rand(2,3) 2\u00d73 Array{Float64,2}: 0.340534 0.885904 0.101062 0.374042 0.735454 0.87115 D = ones(4,2) 4\u00d72 Array{Float64,2}: 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 Unlike Matlab, entries of matrices are accessed with square brackets, rather than parenthesis. Index counting starts at 1 (not 0). C[1,1] 0.34053376741471464 C[1,:] 3-element Array{Float64,1}: 0.34053376741471464 0.885904149330188 0.10106172780311784 C[1,2:end] 2-element Array{Float64,1}: 0.885904149330188 0.10106172780311784 Another useful structure, e.g. for plotting is range. r = 1:2:10 print(typeof(r)) StepRange{Int64,Int64} You can convert the vectors r to regular Julia arrays using the collect function: collect(r) 5-element Array{Int64,1}: 1 3 5 7 9 Similar to Matlab, it is possible to reshape arrays or stack multiple arrays to form new matrices: A = randn(3,4) 3\u00d74 Array{Float64,2}: 0.0369507 0.927287 0.0910324 -0.823177 1.16696 -1.96511 0.514165 -0.282542 -0.191315 0.427349 -0.474449 -0.646095 reshape(A, 4, 3) 4\u00d73 Array{Float64,2}: 0.0369507 -1.96511 -0.474449 1.16696 0.427349 -0.823177 -0.191315 0.0910324 -0.282542 0.927287 0.514165 -0.646095 vec(A) 12-element Array{Float64,1}: 0.036950663624245546 1.166961382172285 -0.19131484147164307 0.9272871492954569 -1.9651066634883936 0.4273486305806718 0.09103240076728031 0.5141654653005298 -0.4744493116000106 -0.8231770890847984 -0.2825422481869328 -0.6460948383122057 B = [A; A] 6\u00d74 Array{Float64,2}: 0.0369507 0.927287 0.0910324 -0.823177 1.16696 -1.96511 0.514165 -0.282542 -0.191315 0.427349 -0.474449 -0.646095 0.0369507 0.927287 0.0910324 -0.823177 1.16696 -1.96511 0.514165 -0.282542 -0.191315 0.427349 -0.474449 -0.646095 One of the pitfalls of Julia is that assigning an array with the equal sign, does not copy the array, but creates a referece. A = ones(2,3) 2\u00d73 Array{Float64,2}: 1.0 1.0 1.0 1.0 1.0 1.0 B = A 2\u00d73 Array{Float64,2}: 1.0 1.0 1.0 1.0 1.0 1.0 A[1,:] .= 2 println(A) [2.0 2.0 2.0; 1.0 1.0 1.0] show(B) [2.0 2.0 2.0; 1.0 1.0 1.0] To copy an array, use the copy function A = ones(2,3) 2\u00d73 Array{Float64,2}: 1.0 1.0 1.0 1.0 1.0 1.0 B = copy(A) 2\u00d73 Array{Float64,2}: 1.0 1.0 1.0 1.0 1.0 1.0 A[1,:] .= 2 println(A) [2.0 2.0 2.0; 1.0 1.0 1.0] println(B) [1.0 1.0 1.0; 1.0 1.0 1.0] We see that B has not been changed! Some other differences between Matlab and Julia are min and max functions. These functions only return the min/max of two input variables: min(5,100) 5 To obtain the smallest/largest entry of a vector, use the minimum and maximum functions: x = [1,2,3,4,5,6] println(minimum(x)) println(maximum(x)) 1 6 Controll Flow Control flow in Julia, i.e. if/else statements, for loops or while loops, are similar to other programming languages. Here are some examples of different ways of controlling the flow: for j=1:2:8 println(j) end 1 3 5 7 for color in [\"red\", \"green\", \"blue\"] # an array print(color, \" \") end red green blue x = 10 while x > 1 x -= 1 println(x) end 9 8 7 6 5 4 3 2 1 name = \"Julia\" if name == \"Julia\" println(\"I like Julia\") elseif name == \"Python\" println(\"I like Python.\") println(\"But I prefer Julia.\") else println(\"I don't know what I like\") end I like Julia Functions Functions are a useful building block to structure your code and build subroutines etc. The most generic way to define functions in Julia is like this: function my_function(arg1, arg2) # do some work end my_function (generic function with 1 method) Functions can have any number of input arguments, including none: function breakfast() maketoast() brewcoffee() end breakfast (generic function with 1 method) By default, Julia functions always return the output from the last line of function. By using the return keyword, you can indicate a specific value that should be returned. function my_func(x, y) x_new = 2x y_new = 2y end z = my_func(3,4) 8 function my_func(x, y) return x_new = 2x y_new = 2y end z = my_func(3,4) 6 By grouping results as tuples, it is possible to return multiple variables: function my_func(x, y) x_new = 2x y_new = 2y return (x_new, y_new) end z = my_func(3,4) (6, 8)","title":"A quick introduction to the Julia language"},{"location":"Assignments/introduction_to_julia/#a-quick-introduction-to-the-julia-language","text":"Getting started Start an interactive Julia session by running julia from the command line. You can quit the session with exit(). Generally, all functions in Julia are run using parenthesis, even if there are no input arguments. pwd() \"/home/yzhang3198\" You can define Julia scripts as regular text files that end with .jl and use your favourite text editor to code. Once you have your script, e.g.: hello-world.jl println(\"Hello world\") Hello world you can run the script with include(\"hello-world.jl\"). The Julia REPL REPL stands for Read/Evaluate/Print/Loop and refers to the interactive Julia session (it's just like a Matlab session). It's good for experimenting, but any serious coding should be done using scripts instead. 42 42 4+5 9 Unlike Matlab, you can access Julia's help functions by typing the question mark, followed by the function that you want the documention of: ? exit search: \u001b[0m\u001b[1me\u001b[22m\u001b[0m\u001b[1mx\u001b[22m\u001b[0m\u001b[1mi\u001b[22m\u001b[0m\u001b[1mt\u001b[22m at\u001b[0m\u001b[1me\u001b[22m\u001b[0m\u001b[1mx\u001b[22m\u001b[0m\u001b[1mi\u001b[22m\u001b[0m\u001b[1mt\u001b[22m t\u001b[0m\u001b[1me\u001b[22m\u001b[0m\u001b[1mx\u001b[22mtw\u001b[0m\u001b[1mi\u001b[22md\u001b[0m\u001b[1mt\u001b[22mh proc\u001b[0m\u001b[1me\u001b[22mss_e\u001b[0m\u001b[1mx\u001b[22m\u001b[0m\u001b[1mi\u001b[22m\u001b[0m\u001b[1mt\u001b[22med ind\u001b[0m\u001b[1me\u001b[22m\u001b[0m\u001b[1mx\u001b[22m\u001b[0m\u001b[1mi\u001b[22mn n\u001b[0m\u001b[1me\u001b[22m\u001b[0m\u001b[1mx\u001b[22mt\u001b[0m\u001b[1mi\u001b[22mnd Ind\u001b[0m\u001b[1me\u001b[22m\u001b[0m\u001b[1mx\u001b[22mL\u001b[0m\u001b[1mi\u001b[22mnear exit(code=0) Stop the program with an exit code. The default exit code is zero, indicating that the program completed successfully. In an interactive session, exit() can be called with the keyboard shortcut ^D . exit() Quit the program indicating that the processes completed successfully. This function calls exit(0) (see exit). Similarly, you can enter the shell mode by typing ;, which gives you access to a full bash terminal. ; pwd /home/yzhang3198 In contrast to Matlab, Julia treats all operators as functions. This means you can add two numbers in either of the two ways: a = 4 + 5 9 a = +(4, 5) 9 The same applies for any other operations, such as subtraction, multiplications etc. Some math constants are defined in Julia by default, such as: print(pi) \u03c0 Julia was designed with the intend to write code that resembles mathematics as close as possible. For example, you can omit the multiplication operator when working with variables: x = 5 2x + 4 # which is the same as 2*x + 4 14 Just as Matlab, but different than Python, Julia comes with many built-in math functions that you would need for everyday use: sin(pi / 2) 1.0 log(100) 4.605170185988092 exp(4.3) 73.69979369959579 rand() 0.24072220081526052","title":"A quick introduction to the Julia language"},{"location":"Assignments/introduction_to_julia/#packages-and-plotting","text":"Packages provide additional functionalities, that are not included in core Julia. Packages are written both by official Julia programmers, as well as anyone else who programs in Julia. Since native Julia does not include any plotting tools, we have to download a third-party package, such as PyPlot or Plots: using Pkg Pkg.add(\"PyPlot\") \u001b[32m\u001b[1m Updating\u001b[22m\u001b[39m registry at `~/.julia/registries/General` \u001b[32m\u001b[1m Updating\u001b[22m\u001b[39m git-repo `https://github.com/JuliaRegistries/General.git` \u001b[2K\u001b[?25h[1mFetching:\u001b[22m\u001b[39m [========================================>] 99.9 %0.0 %] 14.5 %============> ] 29.0 %43.4 %> ] 57.9 % [=============================> ] 72.4 %86.7 %\u001b[32m\u001b[1m Resolving\u001b[22m\u001b[39m package versions... \u001b[32m\u001b[1m Installed\u001b[22m\u001b[39m AWSS3 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 v0.6.6 \u001b[32m\u001b[1m Installed\u001b[22m\u001b[39m AbstractTrees \u2500\u2500 v0.3.1 \u001b[32m\u001b[1m Installed\u001b[22m\u001b[39m DataStructures \u2500 v0.17.9 \u001b[32m\u001b[1m Installed\u001b[22m\u001b[39m ZMQ \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 v1.1.0 \u001b[32m\u001b[1m Installed\u001b[22m\u001b[39m NNlib \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 v0.6.4 \u001b[32m\u001b[1m Installed\u001b[22m\u001b[39m ForwardDiff \u2500\u2500\u2500\u2500 v0.10.9 \u001b[32m\u001b[1m Updating\u001b[22m\u001b[39m `~/.julia/environments/v1.2/Project.toml` \u001b[90m [no changes]\u001b[39m \u001b[32m\u001b[1m Updating\u001b[22m\u001b[39m `~/.julia/environments/v1.2/Manifest.toml` \u001b[90m [1c724243]\u001b[39m\u001b[93m \u2191 AWSS3 v0.6.5 \u21d2 v0.6.6\u001b[39m \u001b[90m [1520ce14]\u001b[39m\u001b[93m \u2191 AbstractTrees v0.2.1 \u21d2 v0.3.1\u001b[39m \u001b[90m [864edb3b]\u001b[39m\u001b[93m \u2191 DataStructures v0.17.7 \u21d2 v0.17.9\u001b[39m \u001b[90m [f6369f11]\u001b[39m\u001b[93m \u2191 ForwardDiff v0.10.8 \u21d2 v0.10.9\u001b[39m \u001b[90m [872c559c]\u001b[39m\u001b[93m \u2191 NNlib v0.6.2 \u21d2 v0.6.4\u001b[39m \u001b[90m [c2297ded]\u001b[39m\u001b[93m \u2191 ZMQ v1.0.0 \u21d2 v1.1.0\u001b[39m \u001b[32m\u001b[1m Building\u001b[22m\u001b[39m ZMQ \u2500\u2500\u2192 `~/.julia/packages/ZMQ/ItfqT/deps/build.log` \u001b[32m\u001b[1m Building\u001b[22m\u001b[39m NNlib \u2192 `~/.julia/packages/NNlib/3krvM/deps/build.log` Once you have downloaded a package, you can use it by typing: using PyPlot \u250c Info: Recompiling stale cache file /home/yzhang3198/.julia/compiled/v1.2/PyPlot/oatAj.ji for PyPlot [d330b81b-6aea-500a-939a-2ce795aea3ee] \u2514 @ Base loading.jl:1240 This plotting package is based off Python's Matplotlib package and therefore shares much of the Syntax. Some common plotting commands include: x = 1:100; f = x .^ 2; plot(x, f) 1-element Array{PyCall.PyObject,1}: PyObject <matplotlib.lines.Line2D object at 0x7fdfe39703c8> A = randn(20,30); imshow(A, extent=[0,30,20,40]) PyObject <matplotlib.image.AxesImage object at 0x7fdfe32bcef0>","title":"Packages and Plotting"},{"location":"Assignments/introduction_to_julia/#arrays-and-tuples","text":"Arrays are defined in a similar fashion to Matlab: x = [1, 2, 3, 4, 5] 5-element Array{Int64,1}: 1 2 3 4 5 As you can see from the output on the screen, Julia actually cares about types of variables and arrays. Since we defined our array as a collection of integers, the type of our array is `{Int64,1} y = [1., 2., 3., 4., 5.] 5-element Array{Float64,1}: 1.0 2.0 3.0 4.0 5.0 You can make a vector out of anything, not just numbers. For example, you can collect strings in a vector like this: s = [\"This\", \"is\", \"a\", \"string\", \"vector\"] 5-element Array{String,1}: \"This\" \"is\" \"a\" \"string\" \"vector\" s = [\"string\", 4.0, sin, pi] 4-element Array{Any,1}: \"string\" 4.0 sin \u03c0 Multi-dimensional arrays are formed as follows: A = [1 2 3 4; 5 6 7 8] 2\u00d74 Array{Int64,2}: 1 2 3 4 5 6 7 8 Note that entries of the same row are separated by spaces and rows are separated by ; You can also initialize vectors/matrices of a given dimension in various ways: B = zeros(4,5) 4\u00d75 Array{Float64,2}: 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 C = rand(2,3) 2\u00d73 Array{Float64,2}: 0.340534 0.885904 0.101062 0.374042 0.735454 0.87115 D = ones(4,2) 4\u00d72 Array{Float64,2}: 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 Unlike Matlab, entries of matrices are accessed with square brackets, rather than parenthesis. Index counting starts at 1 (not 0). C[1,1] 0.34053376741471464 C[1,:] 3-element Array{Float64,1}: 0.34053376741471464 0.885904149330188 0.10106172780311784 C[1,2:end] 2-element Array{Float64,1}: 0.885904149330188 0.10106172780311784 Another useful structure, e.g. for plotting is range. r = 1:2:10 print(typeof(r)) StepRange{Int64,Int64} You can convert the vectors r to regular Julia arrays using the collect function: collect(r) 5-element Array{Int64,1}: 1 3 5 7 9 Similar to Matlab, it is possible to reshape arrays or stack multiple arrays to form new matrices: A = randn(3,4) 3\u00d74 Array{Float64,2}: 0.0369507 0.927287 0.0910324 -0.823177 1.16696 -1.96511 0.514165 -0.282542 -0.191315 0.427349 -0.474449 -0.646095 reshape(A, 4, 3) 4\u00d73 Array{Float64,2}: 0.0369507 -1.96511 -0.474449 1.16696 0.427349 -0.823177 -0.191315 0.0910324 -0.282542 0.927287 0.514165 -0.646095 vec(A) 12-element Array{Float64,1}: 0.036950663624245546 1.166961382172285 -0.19131484147164307 0.9272871492954569 -1.9651066634883936 0.4273486305806718 0.09103240076728031 0.5141654653005298 -0.4744493116000106 -0.8231770890847984 -0.2825422481869328 -0.6460948383122057 B = [A; A] 6\u00d74 Array{Float64,2}: 0.0369507 0.927287 0.0910324 -0.823177 1.16696 -1.96511 0.514165 -0.282542 -0.191315 0.427349 -0.474449 -0.646095 0.0369507 0.927287 0.0910324 -0.823177 1.16696 -1.96511 0.514165 -0.282542 -0.191315 0.427349 -0.474449 -0.646095 One of the pitfalls of Julia is that assigning an array with the equal sign, does not copy the array, but creates a referece. A = ones(2,3) 2\u00d73 Array{Float64,2}: 1.0 1.0 1.0 1.0 1.0 1.0 B = A 2\u00d73 Array{Float64,2}: 1.0 1.0 1.0 1.0 1.0 1.0 A[1,:] .= 2 println(A) [2.0 2.0 2.0; 1.0 1.0 1.0] show(B) [2.0 2.0 2.0; 1.0 1.0 1.0] To copy an array, use the copy function A = ones(2,3) 2\u00d73 Array{Float64,2}: 1.0 1.0 1.0 1.0 1.0 1.0 B = copy(A) 2\u00d73 Array{Float64,2}: 1.0 1.0 1.0 1.0 1.0 1.0 A[1,:] .= 2 println(A) [2.0 2.0 2.0; 1.0 1.0 1.0] println(B) [1.0 1.0 1.0; 1.0 1.0 1.0] We see that B has not been changed! Some other differences between Matlab and Julia are min and max functions. These functions only return the min/max of two input variables: min(5,100) 5 To obtain the smallest/largest entry of a vector, use the minimum and maximum functions: x = [1,2,3,4,5,6] println(minimum(x)) println(maximum(x)) 1 6","title":"Arrays and tuples"},{"location":"Assignments/introduction_to_julia/#controll-flow","text":"Control flow in Julia, i.e. if/else statements, for loops or while loops, are similar to other programming languages. Here are some examples of different ways of controlling the flow: for j=1:2:8 println(j) end 1 3 5 7 for color in [\"red\", \"green\", \"blue\"] # an array print(color, \" \") end red green blue x = 10 while x > 1 x -= 1 println(x) end 9 8 7 6 5 4 3 2 1 name = \"Julia\" if name == \"Julia\" println(\"I like Julia\") elseif name == \"Python\" println(\"I like Python.\") println(\"But I prefer Julia.\") else println(\"I don't know what I like\") end I like Julia","title":"Controll Flow"},{"location":"Assignments/introduction_to_julia/#functions","text":"Functions are a useful building block to structure your code and build subroutines etc. The most generic way to define functions in Julia is like this: function my_function(arg1, arg2) # do some work end my_function (generic function with 1 method) Functions can have any number of input arguments, including none: function breakfast() maketoast() brewcoffee() end breakfast (generic function with 1 method) By default, Julia functions always return the output from the last line of function. By using the return keyword, you can indicate a specific value that should be returned. function my_func(x, y) x_new = 2x y_new = 2y end z = my_func(3,4) 8 function my_func(x, y) return x_new = 2x y_new = 2y end z = my_func(3,4) 6 By grouping results as tuples, it is possible to return multiple variables: function my_func(x, y) x_new = 2x y_new = 2y return (x_new, y_new) end z = my_func(3,4) (6, 8)","title":"Functions"},{"location":"exercise/exercise1/","text":"Exercise 1 Question 1 In the lectures, we learn from slide 40 of lecture 1 that the thickness of a gas or oil column can be retained by \\(z_g = \\frac{2 \\gamma \\cos\\theta (1/r_{cap}-1/r_{res})}{g (\\rho_w-\\rho_g)}\\) Please estimate the range of \\(z_g\\) for a CO \\(_2\\) reservoir. Free feel to search for some values in this formula and you can also follow some of the references below https://onlinelibrary.wiley.com/doi/epdf/10.1111/j.1468-8123.2007.00168.x https://link.springer.com/content/pdf/10.1007/s13202-021-01298-9.pdf https://www.sciencedirect.com/science/article/pii/S0927775721009870?via%3Dihub","title":"Exercise 1"},{"location":"exercise/exercise1/#exercise-1","text":"","title":"Exercise 1"},{"location":"exercise/exercise1/#question-1","text":"In the lectures, we learn from slide 40 of lecture 1 that the thickness of a gas or oil column can be retained by \\(z_g = \\frac{2 \\gamma \\cos\\theta (1/r_{cap}-1/r_{res})}{g (\\rho_w-\\rho_g)}\\) Please estimate the range of \\(z_g\\) for a CO \\(_2\\) reservoir. Free feel to search for some values in this formula and you can also follow some of the references below https://onlinelibrary.wiley.com/doi/epdf/10.1111/j.1468-8123.2007.00168.x https://link.springer.com/content/pdf/10.1007/s13202-021-01298-9.pdf https://www.sciencedirect.com/science/article/pii/S0927775721009870?via%3Dihub","title":"Question 1"},{"location":"exercise/exercise2/","text":"Exercise 2 Question 1 In the lectures, we learn from slide 75 of lecture 1 that the capacity coefficient of a reservoir can be computed by \\(C_c = \\frac{V_{injected}}{V_{PV}} = \\frac{Q_{well}t}{\\phi B\\pi r_{max}^2}\\) Now assume the reservoir is in a circular shape, and (i) 7 million metric ton of supercritical CO \\(_2\\) is injected every year (ii) reservoir is 200m thick and 10km wide (diameter) (iii) porosity of rocks in the reservoir is 30% Q1.1 Please calculate the reservoir capacity coefficient after 20, 30, 50, 100 years of injection. Q1.2 Please calculate the reservoir capacity coefficient after 20, 30, 50, 100 years of injection if the shape of reservoir is a cone instead of a circular shape (width remains the same). Q1.3 Please calculate the reservoir capacity coefficient after 20, 30, 50, 100 years of injection if the porosity of the rocks in the left half of the circular reservoir is changed to 20%. Q1.4 Briefly discuss how you would calculate the capacity coefficient if the reservoir is in an irregular shape with hetergeneous porosity.","title":"Exercise 2"},{"location":"exercise/exercise2/#exercise-2","text":"","title":"Exercise 2"},{"location":"exercise/exercise2/#question-1","text":"In the lectures, we learn from slide 75 of lecture 1 that the capacity coefficient of a reservoir can be computed by \\(C_c = \\frac{V_{injected}}{V_{PV}} = \\frac{Q_{well}t}{\\phi B\\pi r_{max}^2}\\) Now assume the reservoir is in a circular shape, and (i) 7 million metric ton of supercritical CO \\(_2\\) is injected every year (ii) reservoir is 200m thick and 10km wide (diameter) (iii) porosity of rocks in the reservoir is 30%","title":"Question 1"},{"location":"exercise/exercise2/#q11","text":"Please calculate the reservoir capacity coefficient after 20, 30, 50, 100 years of injection.","title":"Q1.1"},{"location":"exercise/exercise2/#q12","text":"Please calculate the reservoir capacity coefficient after 20, 30, 50, 100 years of injection if the shape of reservoir is a cone instead of a circular shape (width remains the same).","title":"Q1.2"},{"location":"exercise/exercise2/#q13","text":"Please calculate the reservoir capacity coefficient after 20, 30, 50, 100 years of injection if the porosity of the rocks in the left half of the circular reservoir is changed to 20%.","title":"Q1.3"},{"location":"exercise/exercise2/#q14","text":"Briefly discuss how you would calculate the capacity coefficient if the reservoir is in an irregular shape with hetergeneous porosity.","title":"Q1.4"}]}